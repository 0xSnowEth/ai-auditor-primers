    // No roles can ever be granted!
}
```

**Impact**:
- Config functions permanently inaccessible
- Claim function always reverts (sends to address(0))

**Mitigation**: Initialize roles in constructor.

### 167. Share/Asset Confusion in Vault Redeem (LoopFi)
**Pattern**: Using shares as assets in reward pool operations.

**Vulnerable Code Example** (LoopFi):
```solidity
function redeem(uint256 shares, address receiver, address owner) public override returns (uint256) {
    uint256 assets = IPool(rewardPool).redeem(shares, address(this), address(this));
    // rewardPool expects assets, not shares!
}
```

**Impact**: Users receive less assets than entitled.

**Mitigation**: Convert shares to assets before calling rewardPool.

### 168. Front-Running Liquidation DoS (LoopFi)
**Pattern**: Borrowers can front-run liquidations with minimal repayments.

**Vulnerable Code Example** (LoopFi):
```solidity
function liquidatePosition(address owner, uint256 repayAmount) external {
    // If debt < repayAmount, calcDecrease underflows
    (newDebt, ...) = calcDecrease(deltaDebt, debtData.debt, ...);
}
```

**Attack**: Repay 1 wei before liquidation to cause underflow.

**Impact**: Liquidations permanently blocked.

**Mitigation**: Handle case where repayAmount > current debt.

### 169. Interest Rate Manipulation Through Cycles (LoopFi)
**Pattern**: Rapid borrow-repay cycles compound interest rates.

**Vulnerable Code Example** (LoopFi):
```solidity
function _updateBaseInterest(...) internal {
    if (block.timestamp != lastBaseInterestUpdate_) {
        _baseInterestIndexLU = _calcBaseInterestIndex(lastBaseInterestUpdate_).toUint128();
        // Compounds on every update!
    }
}
```

**Impact**: Higher interest rates for all borrowers without risk to attacker.

**Mitigation**: Add borrowing fees or minimum loan duration.

### 170. Reward Overwrite in vestTokens (LoopFi)
**Pattern**: Missing state update causes previous rewards to be erased.

**Vulnerable Code Example** (LoopFi):
```solidity
function vestTokens(address user, uint256 amount, bool withPenalty) external {
    if (user == address(this)) {
        _notifyReward(address(rdntToken), amount); // Missing _updateReward!
        return;
    }
}
```

**Impact**: Users lose all previously accumulated rewards.

**Mitigation**: Call `_updateReward` before `_notifyReward`.

### 171. Position Increase During Liquidation (LoopFi)
**Pattern**: Missing position address in decrease lever operations.

**Vulnerable Code Example** (LoopFi):
```solidity
function _onDecreaseLever(LeverParams memory leverParams, uint256 subCollateral) internal returns (uint256) {
    uint256 withdrawnCollateral = ICDPVault(leverParams.vault).withdraw(address(this), subCollateral);
    // Should withdraw from leverParams.position!
}
```

**Impact**: Decrease lever operations always revert.

**Mitigation**: Use correct position address for withdrawals.

### 172. Interest Calculation Mismatch (LoopFi)
**Pattern**: Pool uses simple interest while positions use compound interest.

**Vulnerable Code Example** (LoopFi):
```solidity
// Pool: borrowed * rate * time
function _calcBaseInterestAccrued(uint256 timestamp) private view returns (uint256) {
    return (_totalDebt.borrowed * baseInterestRate().calcLinearGrowth(timestamp)) / RAY;
}

// Position: Compounds through index updates
function _calcBaseInterestIndex(uint256 timestamp) private view returns (uint256) {
    return (_baseInterestIndexLU * (RAY + baseInterestRate().calcLinearGrowth(timestamp))) / RAY;
}
```

**Impact**:
- Borrowers pay more than expected
- Protocol accounting inconsistencies
- Final withdrawals may revert

**Mitigation**: Align interest calculation methods.

### 173. Liquidation Debt Precision Loss (LoopFi)
**Pattern**: Full debt liquidation nearly impossible due to timing.

**Vulnerable Code Example** (LoopFi):
```solidity
function liquidatePosition(address owner, uint256 repayAmount) external {
    if (deltaDebt == maxRepayment) {
        // Must be exact to the second!
        newDebt = 0;
    } else {
        // Reverts if deltaDebt > maxRepayment
    }
}
```

**Impact**: Bad debt accumulation over time.

**Mitigation**: Allow slight overpayment with refund mechanism.

### 174. Bad Debt Interest Loss (LoopFi)
**Pattern**: Interest not credited to LPs during bad debt liquidation.

**Vulnerable Code Example** (LoopFi):
```solidity
function liquidatePositionBadDebt(address owner, uint256 repayAmount) external {
    pool.repayCreditAccount(debtData.debt, 0, loss); // profit = 0!
    // debtData.accruedInterest is lost
}
```

**Impact**: LP stakers lose accrued interest on bad debt positions.

**Mitigation**: Include accrued interest as profit parameter.

### 175. Flash Loan Fee Accounting Error (LoopFi)
**Pattern**: Flash loan fees incorrectly handled as debt repayment.

**Vulnerable Code Example** (LoopFi):
```solidity
function flashLoan(...) external returns (bool) {
    pool.repayCreditAccount(total - fee, fee, 0);
    // Should use mintProfit() for fees!
}
```

**Impact**: WETH locked in pool, withdrawal failures.

**Mitigation**: Use `mintProfit()` for flash loan fees.

### 176. Infinite Loop in Withdraw (LoopFi)
**Pattern**: Loop counter not incremented on zero amounts.

**Vulnerable Code Example** (LoopFi):
```solidity
for (i = 0; ; ) {
    uint256 earnedAmount = _userEarnings[_address][i].amount;
    if (earnedAmount == 0) continue; // i never incremented!
}
```

**Impact**: Withdrawal permanently blocked.

**Mitigation**: Increment counter before continue.

### 177. Reward Distribution Griefing (LoopFi)
**Pattern**: Dust amounts reset reward distribution periods.

**Vulnerable Code Example** (LoopFi):
```solidity
function _notifyUnseenReward(address token) internal {
    uint256 unseen = IERC20(token).balanceOf(address(this)) - r.balance;
    if (unseen > 0) {
        _notifyReward(token, unseen); // Even 1 wei resets!
    }
}
```

**Attack**: Send 1 wei repeatedly to extend vesting periods.

**Impact**: Legitimate rewards delayed indefinitely.

**Mitigation**: Implement minimum reward thresholds.

### 178. CDP Liquidation Manipulation via Partial Liquidations (LoopFi)
**Pattern**: Partial liquidations can temporarily make unsafe positions safe, delaying necessary full liquidations.

**Vulnerable Code Example** (LoopFi):
```solidity
function liquidatePosition(address owner, uint256 repayAmount) external whenNotPaused {
    // ... (validation and state loading)
    if (_isCollateralized(calcTotalDebt(debtData), wmul(position.collateral, spotPrice_), config.liquidationRatio))
        revert CDPVault__liquidatePosition_notUnsafe();
    // ... (liquidation calculations)
    position = _modifyPosition(owner, position, newDebt, newCumulativeIndex, -toInt256(takeCollateral), totalDebt);
    // Position can become temporarily safe after partial liquidation
}
```

**Impact**:
- Self-liquidation can protect positions from full liquidation
- Protocol losses increase if collateral continues to fall
- Goes against intended liquidation mechanics

**Mitigation**: Flag positions as unsafe once they cross the threshold, only unflag on collateral deposits.

### 179. Wrong Amount Used in Position Repayments (LoopFi)
**Pattern**: Using user-specified amount instead of actual swapped amount in position actions.

**Vulnerable Code Example** (LoopFi):
```solidity
function _repay(address vault, address position, CreditParams calldata creditParams, PermitParams calldata permitParams) internal {
    uint256 amount = creditParams.amount;
    if (creditParams.auxSwap.assetIn != address(0)) {
        amount = _transferAndSwap(creditParams.creditor, creditParams.auxSwap, permitParams);
        // amount is now the swapped amount
    }
    // ... but still uses creditParams.amount!
    ICDPVault(vault).modifyCollateralAndDebt(position, address(this), address(this), 0, -toInt256(creditParams.amount));
}
```

**Impact**: Transactions revert due to insufficient balance when swap returns different amount.

**Mitigation**: Use the actual swapped amount for vault operations.

### 180. Swap Token Calculation Error for EXACT_OUT (LoopFi)
**Pattern**: Always returning last asset for Balancer swaps regardless of swap type.

**Vulnerable Code Example** (LoopFi):
```solidity
function getSwapToken(SwapParams memory swapParams) public pure returns (address token) {
    if (swapParams.swapProtocol == SwapProtocol.BALANCER) {
        (, address[] memory primarySwapPath) = abi.decode(swapParams.args, (bytes32, address[]));
        token = primarySwapPath[primarySwapPath.length - 1]; // Wrong for EXACT_OUT!
    }
}
```

**Impact**: Wrong token identification for EXACT_OUT swaps where assets are in reverse order.

**Mitigation**: Check swap type and return appropriate token:
```solidity
if (swapParams.swapType == SwapType.EXACT_OUT) token = primarySwapPath[0];
else token = primarySwapPath[primarySwapPath.length - 1];
```

### 181. Hardcoded Inflation Protection Time (LoopFi)
**Pattern**: Using hardcoded timestamp instead of relative time for reward distribution.

**Vulnerable Code Example** (LoopFi):
```solidity
uint256 private constant INFLATION_PROTECTION_TIME = 1749120350; // Fixed timestamp!

function claim(uint256[] memory amounts, uint256 maxAmountIn) external returns (uint256 amountIn) {
    // ...
    if (block.timestamp <= INFLATION_PROTECTION_TIME) {
        IERC20(AURA).safeTransfer(_config.lockerRewards, (amounts[1] * _config.lockerIncentive) / INCENTIVE_BASIS);
        IERC20(AURA).safeTransfer(msg.sender, amounts[1]);
    }
}
```

**Impact**: Reward distribution window shrinks with each passing day; if deployed too late, no AURA rewards distributed.

**Mitigation**: Set protection time in constructor:
```solidity
uint256 private immutable INFLATION_PROTECTION_TIME;
constructor(...) {
    INFLATION_PROTECTION_TIME = block.timestamp + 365 days;
}
```

### 182. Position Action Lever Functions Always Fail (LoopFi)
**Pattern**: Depositing collateral twice in the same transaction causing reverts.

**Vulnerable Code Example** (LoopFi):
```solidity
function _onIncreaseLever(LeverParams memory leverParams, uint256 upFrontAmount, uint256 addCollateralAmount)
    internal override returns (uint256) {
    // First deposit
    return ICDPVault(leverParams.vault).deposit(address(this), addCollateralAmount);
}

// Later in onFlashLoan:
ICDPVault(leverParams.vault).modifyCollateralAndDebt(
    leverParams.position,
    address(this),
    address(this),
    toInt256(collateral), // Tries to deposit AGAIN!
    toInt256(addDebt)
);
```

**Impact**: increaseLever functionality completely broken for ERC4626 positions.

**Mitigation**: Return amount instead of depositing in `_onIncreaseLever`.

### 183. Pool Action Join Parameters Corruption (LoopFi)
**Pattern**: Incorrect array indexing when updating Balancer pool join parameters.

**Vulnerable Code Example** (LoopFi):
```solidity
function updateLeverJoin(...) external view returns (PoolActionParams memory outParams) {
    // ...
    for (uint256 i = 0; i < len; ) {
        uint256 assetIndex = i - (skipIndex ? 1 : 0);
        if (assets[i] == joinToken) {
            maxAmountsIn[i] = joinAmount;
            assetsIn[assetIndex] = joinAmount; // Wrong index if BPT not found!
        }
        // ...
    }
}
```

**Impact**: Balancer joins fail due to mismatched array indices between assets and amounts.

**Mitigation**: Properly identify pool token from Balancer vault before processing.

### 184. Wrong Collateral Amount in Decrease Lever (LoopFi)
**Pattern**: Updating wrong token amount as collateral withdrawn from vault.

**Vulnerable Code Example** (LoopFi):
```solidity
function _onDecreaseLever(LeverParams memory leverParams, uint256 subCollateral)
    internal override returns (uint256 tokenOut) {
    uint256 withdrawnCollateral = ICDPVault(leverParams.vault).withdraw(address(this), subCollateral);
    tokenOut = IERC4626(leverParams.collateralToken).redeem(withdrawnCollateral, address(this), address(this));
    
    if (leverParams.auxAction.args.length != 0) {
        bytes memory exitData = _delegateCall(address(poolAction),
            abi.encodeWithSelector(poolAction.exit.selector, leverParams.auxAction));
        tokenOut = abi.decode(exitData, (uint256)); // Updates with pool exit amount!
    }
}
```

**Impact**: Wrong amount sent to users, funds stuck in contract.

**Mitigation**: Track actual token balance instead of relying on return values.

### 185. Balancer Exit Returns Wrong Amount (LoopFi)
**Pattern**: Returning recipient's total balance instead of amount received from exit.

**Vulnerable Code Example** (LoopFi):
```solidity
function _balancerExit(PoolActionParams memory poolActionParams) internal returns (uint256 retAmount) {
    // ... perform exit ...
    return IERC20(assets[outIndex]).balanceOf(address(poolActionParams.recipient)); // Total balance!
}
```

**Impact**: Inflated return values cause transaction reverts when contract tries to send more than received.

**Mitigation**: Calculate balance difference before and after exit.

### 186. Deprecated Chainlink Function Usage (LoopFi)
**Pattern**: Using deprecated `answeredInRound` which Chainlink no longer supports.

**Vulnerable Code Example** (LoopFi):
```solidity
function _fetchAndValidate(address priceFeed) private view returns (uint256 answer) {
    (, int256 _answer, , uint256 updatedAt, uint80 answeredInRound) = AggregatorV3Interface(priceFeed)
        .latestRoundData();
    // answeredInRound is deprecated!
}
```

**Impact**: Potential incorrect price validation or future breaking changes.

**Mitigation**: Remove usage of `answeredInRound`.

### 187. Minimum Shares Griefing Attack (LoopFi)
**Pattern**: Attacker can force users to leave funds locked or DoS deposits.

**Vulnerable Code Example** (LoopFi):
```solidity
function _checkMinShares() internal view {
    uint256 _totalSupply = totalSupply();
    if(_totalSupply > 0 && _totalSupply < MIN_SHARES) revert MinSharesViolation();
}
```

**Attack Scenarios**:
1. Deposit 1 wei after each user to block full withdrawals
2. Transfer small amount to contract to make deposits require huge amounts

**Impact**: Last withdrawer loses MIN_SHARES worth of funds or deposits blocked.

**Mitigation**: Protocol should fund initial shares and remove check.

### 188. Token Scale Not Applied in Liquidations (LoopFi)
**Pattern**: Sending internal amount instead of scaled amount to liquidators.

**Vulnerable Code Example** (LoopFi):
```solidity
function liquidatePosition(address owner, uint256 repayAmount) external {
    // ... calculate takeCollateral (internal amount) ...
    token.safeTransfer(msg.sender, takeCollateral); // Should scale by tokenScale!
}

// Compare to withdraw:
function withdraw(address to, uint256 amount) external {
    uint256 amount = wmul(abs(deltaCollateral), tokenScale); // Scales properly
    token.safeTransfer(collateralizer, amount);
}
```

**Impact**: Liquidators receive 100x more tokens than intended for 16-decimal tokens.

**Mitigation**: Apply tokenScale before transfer: `wmul(takeCollateral, tokenScale)`.

### 189. Missing Slippage Protection in Vault Operations (LoopFi)
**Pattern**: No minimum shares/assets parameters in deposit/mint functions.

**Vulnerable Code Example** (LoopFi):
```solidity
function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {
    uint256 shares = previewDeposit(assets);
    _deposit(_msgSender(), receiver, assets, shares);
    // No check that shares >= minShares!
}
```

**Impact**: Users vulnerable to sandwich attacks receiving fewer shares than expected.

**Mitigation**: Add slippage parameters:
```solidity
function deposit(uint256 assets, uint256 minShares, address receiver) public virtual override returns (uint256) {
    uint256 shares = previewDeposit(assets);
    require(shares >= minShares, "Insufficient shares");
    // ...
}
```

### 190. Permit DoS via Front-Running (LoopFi)
**Pattern**: Attacker can extract permit signature and use it first.

**Vulnerable Code Example** (LoopFi):
```solidity
function _transferFrom(address token, address from, address to, uint256 amount, PermitParams memory params) internal {
    if (params.approvalType == ApprovalType.PERMIT) {
        IERC20Permit(token).safePermit(from, to, params.approvalAmount, params.deadline, params.v, params.r, params.s);
        IERC20(token).safeTransferFrom(from, to, amount);
    }
}
```

**Attack**: Front-run with same permit parameters, causing original transaction to fail due to nonce increment.

**Impact**: DoS of permit-based transfers.

**Mitigation**: Use try-catch and check existing allowance as fallback.

### 191. Pause Mechanism Bypass (LoopFi)
**Pattern**: Users can bypass pause by calling underlying functions directly.

**Vulnerable Code Example** (LoopFi):
```solidity
function deposit(address to, uint256 amount) external whenNotPaused returns (uint256 tokenAmount) {
    tokenAmount = wdiv(amount, tokenScale);
    int256 deltaCollateral = toInt256(tokenAmount);
    modifyCollateralAndDebt({...}); // This is public!
}

function modifyCollateralAndDebt(...) public { // No whenNotPaused!
    // Users can call this directly
}
```

**Impact**: Pause mechanism ineffective for protecting protocol.

**Mitigation**: Add `whenNotPaused` to all state-changing functions.

### 192. Incorrect Loss Calculation in Bad Debt (LoopFi)
**Pattern**: Including interest in loss calculation when it was never received.

**Vulnerable Code Example** (LoopFi):
```solidity
function liquidatePositionBadDebt(address owner, uint256 repayAmount) external {
    // ...
    uint256 loss = calcTotalDebt(debtData) - repayAmount; // Includes accruedInterest!
    pool.repayCreditAccount(debtData.debt, 0, loss);
}

function calcTotalDebt(DebtData memory debtData) internal pure returns (uint256) {
    return debtData.debt + debtData.accruedInterest; // Interest is profit, not principal
}
```

**Impact**: Protocol burns extra treasury shares representing "lost" profit that was never earned.

**Mitigation**: Calculate loss as `debtData.debt - repayAmount`.

### 193. Flash Loan Fee Bypass (LoopFi)
**Pattern**: Not accounting for protocol fees in flash loan calculations.

**Vulnerable Code Example** (LoopFi):
```solidity
function decreaseLever(LeverParams memory leverParams) external onlyOwner(leverParams.position) {
    uint256 fee = flashlender.flashFee(leverParams.singleSwap.tokenIn, leverParams.primarySwap.amount);
    uint256 loanAmount = leverParams.primarySwap.amount - fee; // Should add fee!
    // ...
}
```

**Impact**: Insufficient funds to repay flash loan when protocol fee > 0.

**Mitigation**: Calculate as `loanAmount = leverParams.primarySwap.amount - fee` and adjust debt reduction accordingly.

### 194. Loss Not Applied to Pool State (LoopFi)
**Pattern**: Bad debt interest loss not reflected in pool accounting.

**Vulnerable Code Example** (LoopFi):
```solidity
function liquidatePositionBadDebt(address owner, uint256 repayAmount) external {
    // ...
    pool.repayCreditAccount(debtData.debt, 0, loss); // profit = 0, but should include interest
}
```

**Impact**: LPs don't receive accrued interest from bad debt positions.

**Mitigation**: Pass accrued interest as profit parameter.

### 195. Rewards Overwrite via Vesting (LoopFi)
**Pattern**: Anyone can grief users by vesting minimal rewards daily.

**Vulnerable Code Example** (LoopFi):
```solidity
function claim(address onBehalfOf) external {
    uint256 reward = _allPendingRewards[onBehalfOf];
    // Anyone can call this!
    rdntToken_.safeTransfer(address(mfd), reward);
    IMFDPlus(mfd).vestTokens(onBehalfOf, reward, false);
}

// In MultiFeeDistribution:
function vestTokens(address user, uint256 amount, bool withPenalty) external {
    // Creates new entry in _userEarnings array
    // Maximum one entry per day, but anyone can create it
}
```

**Impact**: Array grows to cause DoS when user tries to withdraw after vesting period.

**Mitigation**: Add access control to prevent griefing or allow batch withdrawals.

### 196. Position Action Token Return Scale Errors (LoopFi)
**Pattern**: Position action functions returning amounts in wrong decimal scale.

**Vulnerable Code Example** (LoopFi):
```solidity
function _onWithdraw(address vault, address position, address /*dst*/, uint256 amount)
    internal override returns (uint256) {
    return ICDPVault(vault).withdraw(position, amount); // Returns WAD scale
}

// But caller expects token scale:
function _withdraw(...) internal returns (uint256) {
    uint256 collateral = _onWithdraw(...); // Gets WAD
    IERC20(collateralParams.targetToken).safeTransfer(
        collateralParams.collateralizer,
        collateral // Uses WAD amount for token transfer!
    );
}
```

**Impact**: Withdrawals fail for non-18 decimal tokens due to insufficient balance.

**Mitigation**: Convert return values to proper scale.

### 197. Reward Pool Eligibility Check Race Condition (LoopFi)
**Pattern**: Eligibility checked before refresh, allowing ineligible users to claim.

**Vulnerable Code Example** (LoopFi):
```solidity
function claim(address _user, address[] memory _tokens) public whenNotPaused {
    if (eligibilityMode != EligibilityModes.DISABLED) {
        if (!eligibleDataProvider.isEligibleForRewards(_user)) revert EligibleRequired();
        checkAndProcessEligibility(_user, true, true); // Refresh happens after check!
    }
}
```

**Impact**: Users who lost eligibility due to price changes can still claim rewards.

**Mitigation**: Call `checkAndProcessEligibility` before eligibility check.

### 198. Manual Emissions Stop Balance Sync Issues (LoopFi)
**Pattern**: Setting balances to zero breaks subsequent eligibility updates.

**Vulnerable Code Example** (LoopFi):
```solidity
function manualStopEmissionsFor(address _user, address[] memory _tokens) public isWhitelisted {
    // Sets all balances to 0
    user.amount = 0;
    user.rewardDebt = 0;
    pool.totalSupply = newTotalSupply;
}

// Later when user becomes eligible:
function handleActionAfter(address _user, uint256 _balance, uint256 _totalSupply) external {
    if (isCurrentlyEligible && lastEligibleStatus) {
        _handleActionAfterForToken(msg.sender, _user, _balance, _totalSupply);
        // Only updates one vault, others remain at 0!
    }
}
```

**Impact**: User only earns rewards on one vault after re-gaining eligibility.

**Mitigation**: Update all vault balances when eligibility status changes.

### 199. Reward Time Calculation Discrepancies (LoopFi)
**Pattern**: Pool update timestamps can diverge from mass update timestamps.

**Vulnerable Code Example** (LoopFi):
```solidity
function _updatePool(VaultInfo storage pool, uint256 _totalAllocPoint) internal {
    uint256 timestamp = block.timestamp;
    uint256 endReward = endRewardTime();
    if (endReward <= timestamp) {
        timestamp = endReward; // Pool timestamp < lastAllPoolUpdate
    }
    pool.lastRewardTime = timestamp;
}

// Later:
function endRewardTime() public returns (uint256) {
    uint256 newEndTime = (unclaimedRewards + extra) / rewardsPerSecond + lastAllPoolUpdate;
    // Uses lastAllPoolUpdate which can be > pool timestamps
}
```

**Impact**: Pools can claim rewards beyond depletion time.

**Mitigation**: Synchronize timestamps or adjust endTime calculation.

### 200. Deposit Auxiliary Swap Validation Error (LoopFi)
**Pattern**: Incorrect validation prevents valid swap operations.

**Vulnerable Code Example** (LoopFi):
```solidity
function _deposit(...) internal returns (uint256) {
if (collateralParams.auxSwap.assetIn != address(0)) {
        if (
            collateralParams.auxSwap.assetIn != collateralParams.targetToken || // Wrong check!
            collateralParams.auxSwap.recipient != address(this)
        ) revert PositionAction__deposit_InvalidAuxSwap();
    }
}
```

**Impact**: Cannot swap tokens before depositing, feature completely unusable.

**Mitigation**: Remove the incorrect equality check.

### 201. ERC4626 Position Action Withdraw Address Mismatch (LoopFi)
**Pattern**: Withdrawing from wrong address in position actions.

**Vulnerable Code Example** (LoopFi):
```solidity
function _onWithdraw(address vault, address /*position*/, address dst, uint256 amount)
    internal override returns (uint256) {
    uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);
    // Should use position parameter!
}
```

**Impact**: Cannot withdraw from positions other than the contract itself.

**Mitigation**: Use the position parameter for withdrawals.

### 202. Native ETH Support Missing in Swaps (LoopFi)
**Pattern**: Swap functions don't pass msg.value to external protocols.

**Vulnerable Code Example** (LoopFi):
```solidity
function swap(...) external payable { // Function is payable
    if (swapParams.swapProtocol == SwapProtocol.BALANCER) {
        balancerVault.batchSwap( // Missing: {value: msg.value}
            // ...
        );
    }
}
```

**Impact**: Cannot use native ETH as input for swaps.

**Mitigation**: Pass msg.value in external calls.

### 203. Emission Schedule Update Timing Issues (LoopFi)
**Pattern**: Reward distribution uses old rate during schedule transitions.

**Vulnerable Code Example** (LoopFi):
```solidity
function setScheduledRewardsPerSecond() internal {
    if (i > emissionScheduleIndex) {
        emissionScheduleIndex = i;
        _massUpdatePools(); // Uses old rewardsPerSecond!
        rewardsPerSecond = uint256(emissionSchedule[i - 1].rewardsPerSecond);
    }
}
```

**Impact**: Incorrect reward distribution during schedule changes.

**Mitigation**: Calculate rewards with both old and new rates for transition period.

### 204. ERC4626 Slippage Vulnerability During Vault Operations (LoopFi)
**Pattern**: No slippage protection when interacting with ERC4626 vaults in position actions.

**Vulnerable Code Example** (LoopFi):
```solidity
function _onDeposit(address vault, address /*position*/, address src, uint256 amount)
    internal override returns (uint256) {
    if (src != collateral) {
        IERC20(underlying).forceApprove(collateral, amount);
        amount = IERC4626(collateral).deposit(amount, address(this)); // No slippage check!
    }
    return ICDPVault(vault).deposit(address(this), amount);
}
```

**Impact**: Users vulnerable to sandwich attacks and exchange rate manipulation.

**Mitigation**: Add minimum shares parameter and validation.

### 205. Discount Fee Exploitation via Self-Trading (Ditto)
**Pattern**: Attacker can trigger discount fees and claim them through vault ownership, profiting from the mechanism.

**Vulnerable Code Example** (Ditto):
```solidity
function _matchIsDiscounted(MTypes.HandleDiscount memory h) external onlyDiamond {
    // ...
    if (pctOfDiscountedDebt > C.DISCOUNT_THRESHOLD && !LibTStore.isForcedBid()) {
        // Calculate fee based on total debt
        uint256 discountPenaltyFee = uint64(LibAsset.discountPenaltyFee(Asset));
        uint256 ercDebtMinusTapp = h.ercDebt - Asset.ercDebtFee;
        
        // Mint fee as new debt
        uint104 newDebt = uint104(ercDebtMinusTapp.mul(discountPenaltyFee));
        Asset.ercDebt += newDebt;
        
        // Mint to yDUSD vault
        IERC20(h.asset).mint(s.yieldVault[h.asset], newDebt);
    }
}
```

**Attack Scenario**:
1. Attacker owns significant share of yDUSD vault
2. Creates trades at discount prices to trigger fees
3. Fees minted to vault increase share value
4. Profit exceeds trading losses after 2+ days

**Impact**: Attacker can mint free DUSD by exploiting the fee mechanism.

**Mitigation**: Base fees on actual traded amount rather than total debt.

### 206. Minting DUSD with Less Collateral via Cancel Short (Ditto)
**Pattern**: Using stale price and low CR when canceling partial short positions to mint DUSD with insufficient collateral.

**Vulnerable Code Example** (Ditto):
```solidity
function cancelShort(address asset, uint16 id) internal {
    // ...
    if (shortRecord.status == SR.PartialFill) {
        uint256 minShortErc = LibAsset.minShortErc(Asset);
        if (shortRecord.ercDebt < minShortErc) {
            uint88 debtDiff = uint88(minShortErc - shortRecord.ercDebt);
            
            // Uses stale price and potentially low CR
            uint88 collateralDiff = shortOrder.price.mulU88(debtDiff).mulU88(cr);
            
            // Mints DUSD with less collateral than required
            s.assetUser[asset][shorter].ercEscrowed += debtDiff;
        }
    }
}
```

**Impact**: Users can mint DUSD at below 100% CR, creating unbacked stablecoins.

**Mitigation**: Use current oracle price and enforce minimum CR.

### 207. yDUSD Vault Direct Minting Accounting Bug (Ditto)
**Pattern**: Direct minting to yDUSD vault increases balance without updating totalSupply, breaking share calculations.

**Vulnerable Code Example** (Ditto):
```solidity
// When discount occurs:
IERC20(h.asset).mint(s.yieldVault[h.asset], newDebt); // Increases balance

// Later when users deposit:
function previewDeposit(uint256 assets) public view returns (uint256) {
    return _convertToShares(assets, Math.Rounding.Down);
}

function _convertToShares(uint256 assets, Math.Rounding rounding) internal view returns (uint256) {
    // shares = assets * (0 + 1) / newDebt = 0 (rounds down)
    return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);
}
```

**Impact**: Depositors receive 0 shares and lose all deposited assets.

**Mitigation**: Implement proper auto-compounding mechanism like xERC4626.

### 208. yDUSD Withdrawal Timelock Bypass (Ditto)
**Pattern**: Users can use another account's withdrawal proposal to bypass the 7-day timelock.

**Vulnerable Code Example** (Ditto):
```solidity
function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
    // Uses msg.sender's proposal
    WithdrawStruct storage withdrawal = withdrawals[msg.sender];
    
    // But withdraws from owner's account
    _withdraw(_msgSender(), receiver, owner, amountProposed, shares);
}
```

**Attack**:
1. Attacker approves shares to accomplice
2. Accomplice has existing withdrawal proposal
3. Attacker withdraws using accomplice's timelock status

**Impact**: Complete bypass of 7-day withdrawal timelock.

**Mitigation**: Require `msg.sender == owner` for withdrawals.

### 209. Free DUSD Minting and Liquidation Reward Exploit (Ditto)
**Pattern**: Combining decreaseCollateral and cancelShort with CR < 1 to create liquidatable positions for profit.

**Vulnerable Code Example** (Ditto):
```solidity
// Create short with CR < 1
function createLimitShort(asset, price, minShortErc, orderHintArray, shortHintArray, 70); // 70% CR

// After partial fill:
decreaseCollateral(shortRecordId, amount); // Remove collateral added for minShortErc
cancelShort(orderId); // Mints DUSD with only 70% collateral

// Position now liquidatable
```

**Impact**: Attacker mints free DUSD and earns liquidation rewards.

**Mitigation**: Check resulting CR after operations is above liquidation threshold.

### 210. Arbitrary Call Vulnerability in Funding Withdrawal (JOJO)
**Pattern**: User-controlled external calls during withdrawal allowing arbitrary contract interactions.

**Vulnerable Code Example** (JOJO):
```solidity
function _withdraw(..., address to, ..., bytes memory param) private {
    // ... withdrawal logic ...
    
    if (param.length != 0) {
        require(Address.isContract(to), "target is not a contract");
        (bool success,) = to.call(param); // VULNERABLE: Arbitrary call
        if (success == false) {
            assembly {
                let ptr := mload(0x40)
                let size := returndatasize()
                returndatacopy(ptr, 0, size)
                revert(ptr, size)
            }
        }
    }
}
```

**Attack Vector**: Attacker can execute withdrawal of 1 wei to USDC contract and pass calldata to transfer arbitrary USDC amount to themselves.

**Impact**: Complete drainage of all funds from JOJODealer.

**Mitigation**: Whitelist allowed contracts or remove arbitrary call functionality.

### 211. FundingRateArbitrage Rounding Exploitation (JOJO)
**Pattern**: Incorrect rounding direction in withdrawal calculations allows draining the contract.

**Vulnerable Code Example** (JOJO):
```solidity
function requestWithdraw(uint256 repayJUSDAmount) external {
    jusdOutside[msg.sender] -= repayJUSDAmount;
    uint256 index = getIndex();
    uint256 lockedEarnUSDCAmount = jusdOutside[msg.sender].decimalDiv(index); // Rounds down!
    require(
        earnUSDCBalance[msg.sender] >= lockedEarnUSDCAmount,
        "lockedEarnUSDCAmount is bigger than earnUSDCBalance"
    );
    withdrawEarnUSDCAmount = earnUSDCBalance[msg.sender] - lockedEarnUSDCAmount;
}
```

**Attack Scenario**:
1. Attacker deposits and inflates share price
2. Makes small deposits to get shares
3. Withdraws with minimal JUSD repayment
4. Due to rounding down, gets more USDC than entitled
5. Repeats until contract drained

**Impact**: Complete drainage of JUSD from the contract.

**Mitigation**: Round up instead of down for `lockedEarnUSDCAmount`.

### 212. Interest Rate Calculation Mismatch (JOJO)
**Pattern**: `getTRate()` and `accrueRate()` use different formulas causing calculation discrepancies.

**Vulnerable Code Example** (JOJO):
```solidity
function accrueRate() public {
    uint256 currentTimestamp = block.timestamp;
    if (currentTimestamp == lastUpdateTimestamp) {
        return;
    }
    uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);
    tRate = tRate.decimalMul((timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR + 1e18);
    lastUpdateTimestamp = currentTimestamp;
}

function getTRate() public view returns (uint256) {
    uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);
    return tRate + (borrowFeeRate * timeDifference) / Types.SECONDS_PER_YEAR; // Different formula!
}
```

**Impact**: Incorrect calculations in all dependent functions including liquidations, flash loans, and collateral checks.

**Mitigation**: Use consistent calculation formula in both functions.

### 213. Withdrawal Request Using Wrong Address (JOJO)
**Pattern**: Using `msg.sender` instead of `from` parameter in withdrawal requests.

**Vulnerable Code Example** (JOJO):
```solidity
function requestWithdraw(
    Types.State storage state,
    address from,
    uint256 primaryAmount,
    uint256 secondaryAmount
) external {
    require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);
    state.pendingPrimaryWithdraw[msg.sender] = primaryAmount; // Should be 'from'!
    state.pendingSecondaryWithdraw[msg.sender] = secondaryAmount;
    state.withdrawExecutionTimestamp[msg.sender] = block.timestamp + state.withdrawTimeLock;
    emit RequestWithdraw(msg.sender, primaryAmount, secondaryAmount, state.withdrawExecutionTimestamp[msg.sender]);
}
```

**Impact**: Cannot initiate withdrawals on behalf of other users even with proper allowance, potentially stranding funds.

**Mitigation**: Replace all `msg.sender` occurrences with `from` parameter.

### 214. FundingRateArbitrage Share Inflation Attack (JOJO)
**Pattern**: Classic ERC4626-style inflation attack through donation allowing theft of subsequent deposits.

**Vulnerable Code Example** (JOJO):
```solidity
function getIndex() public view returns (uint256) {
    if (totalEarnUSDCBalance == 0) {
        return 1e18;
    } else {
        return SignedDecimalMath.decimalDiv(getNetValue(), totalEarnUSDCBalance);
    }
}

function deposit(uint256 amount) external {
    // ...
    uint256 earnUSDCAmount = amount.decimalDiv(getIndex());
    // If index is inflated, earnUSDCAmount rounds to 0
}
```

**Attack**:
1. Deposit 1 share
2. Donate 100,000e6 USDC
3. Index becomes 100,000e18
4. Subsequent deposits under 100,000e6 receive 0 shares

**Impact**: Complete theft of subsequent user deposits.

**Mitigation**: Implement virtual offset as recommended by OpenZeppelin.
