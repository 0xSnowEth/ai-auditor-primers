// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import "lib/solmate/src/utils/CREATE3.sol";
import "src/Lender.sol";
import "src/Vault.sol";
import "src/Coin.sol";
import "src/InterestModel.sol";

library InterestModelDeployer {
    function deploy() external returns (address) {
        return address(new InterestModel());
    }
}

library LenderDeployer {
    function getHash(address caller, uint nonce) internal view returns (bytes32) {
        return keccak256(abi.encode("lender", block.chainid, address(this), caller, nonce));
    }

    function getAddress(address caller, uint nonce) external view returns (address) {
        return CREATE3.getDeployed(getHash(caller, nonce));
    }

    function deployLender(address caller, uint nonce, bytes memory data) external {
        CREATE3.deploy(getHash(caller, nonce), abi.encodePacked(type(Lender).creationCode, data), 0);
    }
}

library VaultDeployer {
    function getHash(address caller, uint nonce) internal view returns (bytes32) {
        return keccak256(abi.encode("vault", block.chainid, address(this), caller, nonce));
    }

    function getAddress(address caller, uint nonce) external view returns (address) {
        return CREATE3.getDeployed(getHash(caller, nonce));
    }

    function deployVault(address caller, uint nonce, bytes memory data) external {
        CREATE3.deploy(getHash(caller, nonce), abi.encodePacked(type(Vault).creationCode, data), 0);
    }
}

library CoinDeployer {
    function getHash(address caller, uint nonce) internal view returns (bytes32) {
        return keccak256(abi.encode("coin", block.chainid, address(this), caller, nonce));
    }

    function getAddress(address caller, uint nonce) external view returns (address) {
        return CREATE3.getDeployed(getHash(caller, nonce));
    }

    function deployCoin(address caller, uint nonce, bytes memory data) external {
        CREATE3.deploy(getHash(caller, nonce), abi.encodePacked(type(Coin).creationCode, data), 0);
    }
}

contract Factory {

    address public pendingOperator;
    address public operator;
    address public feeRecipient;
    uint256 public feeBps;
    address public immutable interestModel;
    uint256 public immutable minDebtFloor;
    uint256 public constant MAX_FEE_BPS = 1000; // 10%

    address[] public deployments;
    mapping(address => bool) public isDeployed;
    mapping(address => uint256) public customFeeBps;

    constructor(address _operator, uint256 _minDebtFloor) {
        operator = _operator;
        minDebtFloor = _minDebtFloor;
        interestModel = InterestModelDeployer.deploy();
    }

    modifier onlyOperator() {
        require(msg.sender == operator, "Only operator can call this function");
        _;
    }

    function deploymentsLength() external view returns (uint256) {
        return deployments.length;
    }

    function setPendingOperator(address _pendingOperator) external onlyOperator {
        pendingOperator = _pendingOperator;
        emit PendingOperatorUpdated(_pendingOperator);
    }

    function acceptOperator() external {
        require(msg.sender == pendingOperator, "Only pending operator can accept");
        operator = pendingOperator;
        pendingOperator = address(0);
        emit OperatorUpdated(operator);
    }

    function setFeeRecipient(address _feeRecipient) external onlyOperator {
        feeRecipient = _feeRecipient;
        emit FeeRecipientUpdated(_feeRecipient);
    }

    function setFeeBps(uint256 _feeBps) external onlyOperator {
        require(_feeBps <= MAX_FEE_BPS, "Feebps must be less than or equal to 1000");
        feeBps = _feeBps;
        emit FeeBpsUpdated(_feeBps);
    }

    function setCustomFeeBps(address _address, uint256 _feeBps) external onlyOperator {
        require(_feeBps <= MAX_FEE_BPS, "Feebps must be less than or equal to 1000");
        customFeeBps[_address] = _feeBps;
        emit CustomFeeBpsSet(_address, _feeBps);
    }

    function getFeeOf(address _lender) external view returns (uint256) {
        uint customFee = customFeeBps[_lender];
        if (customFee > 0) return customFee;
        return feeBps;
    }

    function pullReserves(address _deployment) external {
        require(msg.sender == feeRecipient, "Only fee recipient can pull reserves");
        require(isDeployed[_deployment], "Deployment not found");
        Lender(_deployment).pullGlobalReserves(msg.sender);
    }

    struct DeployParams {
        string name;
        string symbol;
        address collateral;
        address psmAsset;
        address psmVault;
        address feed;
        uint256 collateralFactor;
        uint256 minDebt;
        uint256 timeUntilImmutability;
        address operator;
        address manager;
        uint64 halfLife;
        uint16 targetFreeDebtRatioStartBps;
        uint16 targetFreeDebtRatioEndBps;
        uint16 redeemFeeBps;
        uint32 stalenessThreshold;
        uint16 maxBorrowDeltaBps;
        uint128 minTotalSupply;
    }

    function deploy(DeployParams memory params) external returns (address lender, address coin, address vault) {
        uint id = deployments.length;
        lender = LenderDeployer.getAddress(msg.sender, id);
        vault = VaultDeployer.getAddress(msg.sender, id);
        coin = CoinDeployer.getAddress(msg.sender, id);
        // these vars avoid stack too deep
        Lender.LenderParams memory lenderParams = Lender.LenderParams({
            collateral: ERC20(params.collateral),
            psmAsset: ERC20(params.psmAsset),
            psmVault: ERC4626(params.psmVault),
            feed: IChainlinkFeed(params.feed),
            coin: Coin(coin),
            vault: Vault(vault),
            interestModel: InterestModel(interestModel),
            factory: IFactory(address(this)),
            operator: params.operator,
            manager: params.manager,
            collateralFactor: params.collateralFactor,
            minDebt: params.minDebt,
            timeUntilImmutability: params.timeUntilImmutability,
            halfLife: params.halfLife,
            targetFreeDebtRatioStartBps: params.targetFreeDebtRatioStartBps,
            targetFreeDebtRatioEndBps: params.targetFreeDebtRatioEndBps,
            redeemFeeBps: params.redeemFeeBps,
            stalenessThreshold: params.stalenessThreshold,
            maxBorrowDeltaBps: params.maxBorrowDeltaBps,
            minTotalSupply: params.minTotalSupply
        });
        bytes memory lenderData = abi.encode(lenderParams);
        bytes memory vaultData = abi.encode(params.name, params.symbol, lender);
        bytes memory coinData = abi.encode(lender, params.name, params.symbol);
        LenderDeployer.deployLender(msg.sender, id, lenderData);
        CoinDeployer.deployCoin(msg.sender, id, coinData);
        VaultDeployer.deployVault(msg.sender, id, vaultData);
        deployments.push(lender);
        isDeployed[lender] = true;
        emit Deployed(lender, coin, vault);
    }

    event CustomFeeBpsSet(address indexed lender, uint256 feeBps);
    event Deployed(address indexed lender, address indexed coin, address indexed vault);
    event OperatorUpdated(address indexed operator);
    event PendingOperatorUpdated(address indexed pendingOperator);
    event FeeRecipientUpdated(address indexed feeRecipient);
    event FeeBpsUpdated(uint256 feeBps);
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import "lib/solmate/src/tokens/ERC4626.sol";

interface ILender {
    function accrueInterest() external;
    function coin() external view returns (ERC20);
    function getPendingInterest() external view returns (uint256 pendingVaultInterest);
}

contract Vault is ERC4626 {
    using SafeTransferLib for ERC20;
    using FixedPointMathLib for uint256;
    
    ILender public immutable lender;
    uint256 constant MIN_SHARES = 1e16; // 1 cent;

    /// @param _name Name of the token. Prepended with "Staked "
    /// @param _symbol Symbol of the token. Prepended with "s"
    /// @param _lender Address of the Lender token
    constructor(
        string memory _name,
        string memory _symbol,
        address _lender
    ) ERC4626(
        ILender(_lender).coin(),
        string.concat("Staked ", _name),
        string.concat("s", _symbol)
    ) {
        lender = ILender(_lender);
    }

    modifier accrueInterest() {
        lender.accrueInterest();
        _;
    }

    function totalAssets() public view override returns (uint256) {
        return asset.balanceOf(address(this)) + lender.getPendingInterest();
    }

    /// @notice Deposits assets into the vault
    /// @param assets Amount of assets to deposit
    /// @param receiver Address to receive the shares
    /// @return shares Amount of shares minted
    function deposit(uint256 assets, address receiver) public accrueInterest override returns (uint256 shares) {
        bool isFirstDeposit = totalSupply == 0;
       
        // Check for rounding error since we round down in previewDeposit.
        require((shares = convertToShares(assets)) != 0, "ZERO_SHARES");

        // Need to transfer before minting or ERC777s could reenter.
        asset.safeTransferFrom(msg.sender, address(this), assets);

        _mint(receiver, shares);
        
        emit Deposit(msg.sender, receiver, assets, shares);

        if(isFirstDeposit) {
                // if this underflows, the first deposit is less than MIN_SHARES which is not allowed
                balanceOf[receiver] -= MIN_SHARES;
                balanceOf[address(0)] += MIN_SHARES;
                shares -= MIN_SHARES;
                emit Transfer(receiver, address(0), MIN_SHARES);
        }
        
    }

    /// @notice Mints shares of the vault
    /// @dev Includes MIN_SHARES deduction on first deposit, meaning it will pull more assets to burn the MIN_SHARES on first deposit
    /// @param shares Amount of shares to mint
    /// @param receiver Address to receive the shares
    /// @return assets Amount of assets deposited
    function mint(uint256 shares, address receiver) public accrueInterest override returns (uint256 assets) {
        // Get the amount of assets required including amount to burn MIN_SHARES if first deposit
        assets = previewMint(shares); 
        // Need to transfer before minting or ERC777s could reenter.
        asset.safeTransferFrom(msg.sender, address(this), assets);

        bool isFirstDeposit = totalSupply == 0;
        
        if(isFirstDeposit) {
            _mint(receiver, shares + MIN_SHARES);
            // if this underflows, the first deposit is less than MIN_SHARES which is not allowed
            balanceOf[receiver] -= MIN_SHARES;
            balanceOf[address(0)] += MIN_SHARES;
            emit Transfer(receiver, address(0), MIN_SHARES);
        } else {
            _mint(receiver, shares);  
        }

        emit Deposit(msg.sender, receiver, assets, shares);
    }

    /// @notice Withdraws assets from the vault
    /// @param assets Amount of assets to withdraw
    /// @param receiver Address to receive the assets
    /// @param owner Owner of the shares
    /// @return shares Amount of shares burned
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public accrueInterest override returns (uint256 shares) {
        shares = super.withdraw(assets, receiver, owner);
    }

    /// @notice Redeems shares for assets
    /// @param shares Amount of shares to redeem
    /// @param receiver Address to receive the assets
    /// @param owner Owner of the shares
    /// @return assets Amount of assets withdrawn
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public accrueInterest override returns (uint256 assets) {
        assets = super.redeem(shares, receiver, owner);
    }

    /// @notice Preview deposit to account for MIN_SHARES deduction on first deposit
    /// @param assets Amount of assets to deposit
    /// @return shares Amount of shares that will be minted to the user
    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {
        shares = convertToShares(assets);
        if (totalSupply == 0) {
            // Avoid reverting to conforme with ERC4626 spec
            if (shares < MIN_SHARES) {
                shares = 0;
            } else shares -= MIN_SHARES;

        }
    }

    /// @notice Preview mint to account for MIN_SHARES deduction on first deposit
    /// @param shares Amount of shares to mint
    /// @return assets Amount of assets that will be deposited (accounting for MIN_SHARES on first deposit)
    function previewMint(uint256 shares) public view override returns (uint256 assets) {
        // If this is the first deposit, we need to mint MIN_SHARES extra
        if (totalSupply == 0) shares += MIN_SHARES;
        
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);
    }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import "lib/solmate/src/tokens/ERC20.sol";
import "lib/solmate/src/tokens/ERC4626.sol";
import "lib/solmate/src/utils/SafeTransferLib.sol";
import "lib/solmate/src/utils/FixedPointMathLib.sol";
import "./Coin.sol";
import "./Vault.sol";
import "./InterestModel.sol";

interface IChainlinkFeed {
    function decimals() external view returns (uint8);
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

interface IFactory {
    function getFeeOf(address _lender) external view returns (uint256);
    function minDebtFloor() external view returns (uint256);
}

contract Lender {

    using SafeTransferLib for ERC20;
    using FixedPointMathLib for uint256;

    // single 256-bit slot
    uint16 public targetFreeDebtRatioStartBps; // max uint16 is 65535 bps which is outside of the range [0, 10000]
    uint16 public targetFreeDebtRatioEndBps; // max uint16 is 65535 bps which is outside of the range [0, 10000]
    uint16 public redeemFeeBps; // max uint16 is 65535 bps fee which is outside of the range [0, 10000]
    uint64 public expRate; // max result is 693147180559945309 which is within uint64 range
    uint40 public lastAccrue; // max uint40 is year 36812
    uint88 public lastBorrowRateMantissa = uint88(2e16); // max uint88 is equivalent to 309485000% APR
    uint16 public feeBps; // max uint16 is 65535 bps which is outside of the range [0, 10000]
    

    // single 256-bit slot
    uint16 public cachedGlobalFeeBps;
    uint120 public accruedLocalReserves;
    uint120 public accruedGlobalReserves;

    // Other state variables
    address public operator;
    address public pendingOperator;
    uint public immutabilityDeadline; // may only be reduced by operator
    uint public totalFreeDebt;
    uint public totalFreeDebtShares;
    uint public totalPaidDebt;
    uint public totalPaidDebtShares;
    uint public epoch;
    uint public freePsmAssets;
    uint16 public maxBorrowDeltaBps; // max acceptable rounding error in bps when borrowing (e.g., 200 = 2%)
    
    // Constants and immutables
    Coin public immutable coin;
    ERC20 public immutable collateral;
    ERC20 public immutable psmAsset;
    ERC4626 public immutable psmVault;
    IChainlinkFeed public immutable feed;
    Vault public immutable vault;
    InterestModel public immutable interestModel;
    IFactory public immutable factory;
    uint public immutable collateralFactor;
    uint public immutable minDebt;
    uint public immutable minDebtFloor;
    uint public immutable deployTimestamp;
    uint public immutable psmAssetDecimals;
    uint public immutable collateralDecimals;
    uint public immutable stalenessThreshold; 
    uint public immutable minTotalSupply;

    uint public constant STALENESS_UNWIND_DURATION = 24 hours;
    uint public constant MIN_LIQUIDATION_DEBT = 10_000e18; // 10,000 Coin
    uint public constant MAX_DECIMALS = 30; // Maximum allowed token decimals
    
    // For accrueInterest() try-catch
    uint256 private constant INTEREST_CALCULATION_GAS_REQUIREMENT = 40_000;
    // For writeOff() try-catch in liquidate() 
    uint256 private constant WRITEOFF_GAS_REQUIREMENT = 120_000;

    // Mappings
    mapping(address => uint) public _cachedCollateralBalances; // should not be read externally in most cases
    mapping(address => uint) public freeDebtShares;
    mapping(address => uint) public paidDebtShares;
    mapping(address => bool) public isRedeemable;
    mapping(address => mapping(address => bool)) public delegations;

    mapping(address => uint) public borrowerLastRedeemedIndex;
    mapping(address => uint) public borrowerEpoch;
    mapping(uint => uint) public epochRedeemedCollateral;
    uint256 public nonRedeemableCollateral;

    address public manager;

    struct LenderParams {
        ERC20 collateral;
        ERC20 psmAsset; // optional
        ERC4626 psmVault; // optional
        IChainlinkFeed feed;
        Coin coin;
        Vault vault;
        InterestModel interestModel;
        IFactory factory;
        address operator;
        address manager;
        uint collateralFactor;
        uint minDebt;
        uint timeUntilImmutability;
        uint64 halfLife;
        uint16 targetFreeDebtRatioStartBps;
        uint16 targetFreeDebtRatioEndBps;
        uint16 redeemFeeBps;
        uint32 stalenessThreshold;
        uint16 maxBorrowDeltaBps;
        uint128 minTotalSupply;
    }

    constructor(LenderParams memory params) {
        require(params.collateralFactor <= 8500, "Invalid collateral factor");
        require(params.timeUntilImmutability < 1460 days, "Max immutability deadline is in 4 years");
        require(params.halfLife >= 24 hours && params.halfLife <= 30 days, "Invalid half life");
        require(params.targetFreeDebtRatioStartBps >= 500 && params.targetFreeDebtRatioStartBps <= params.targetFreeDebtRatioEndBps, "Invalid start bps");
        require(params.targetFreeDebtRatioEndBps <= 9500, "Invalid end bps");
        require(params.redeemFeeBps <= 1000, "Invalid redeem fee bps");
        require(params.maxBorrowDeltaBps <= 200 && params.maxBorrowDeltaBps >= 50, "Invalid max borrow delta bps"); // Max 5%
        minDebtFloor = IFactory(params.factory).minDebtFloor();
        require(params.minDebt >= minDebtFloor, "Invalid min debt");
       
        if(params.psmVault != ERC4626(address(0))) {
            require(params.psmVault.asset() == params.psmAsset, "PSM asset mismatch");
            require(params.minTotalSupply > 0, "Invalid min total supply");
        }
        
        // Validate collateral decimals
        uint256 _collateralDecimals = params.collateral.decimals();
        require(_collateralDecimals <= MAX_DECIMALS, "Collateral decimals exceed maximum");
        collateralDecimals = _collateralDecimals;
        
        collateral = params.collateral;
        psmAsset = params.psmAsset;
        psmVault = params.psmVault;
        feed = params.feed;
        coin = params.coin;
        vault = params.vault;
        interestModel = params.interestModel;
        factory = params.factory;
        operator = params.operator;
        manager = params.manager;
        collateralFactor = params.collateralFactor;
        minDebt = params.minDebt;
        deployTimestamp = block.timestamp;
        immutabilityDeadline = block.timestamp + params.timeUntilImmutability;
        lastAccrue = uint40(block.timestamp);
        expRate = uint64(uint(wadLn(2*1e18)) / params.halfLife);
        targetFreeDebtRatioStartBps = params.targetFreeDebtRatioStartBps;
        targetFreeDebtRatioEndBps = params.targetFreeDebtRatioEndBps;
        redeemFeeBps = params.redeemFeeBps;
        maxBorrowDeltaBps = params.maxBorrowDeltaBps;
        stalenessThreshold = params.stalenessThreshold;
        minTotalSupply = params.minTotalSupply;
        cachedGlobalFeeBps = uint16(factory.getFeeOf(address(this)));
        if(psmVault != ERC4626(address(0)))
            psmAsset.approve(address(psmVault), type(uint).max);
        uint256 _psmAssetDecimals;
        if (psmAsset != ERC20(address(0))) {
            _psmAssetDecimals = psmAsset.decimals();
        } 
        psmAssetDecimals = _psmAssetDecimals;
    }

    // Modifiers

    modifier onlyOperator() {
        require(msg.sender == operator, "Unauthorized");
        _;
    }

    modifier onlyOperatorOrManager() {
        require(msg.sender == operator || msg.sender == manager, "Unauthorized");
        _;
    }

    modifier beforeDeadline() {
        require(block.timestamp < immutabilityDeadline, "Deadline passed");
        _;
    }

    // Public functions

    function accrueInterest() public {
        uint timeElapsed = block.timestamp - lastAccrue;
        if(timeElapsed == 0) return;

        uint256 gasBefore = gasleft();

        try interestModel.calculateInterest(
            totalPaidDebt,
            lastBorrowRateMantissa,
            timeElapsed,
            expRate,
            getFreeDebtRatio(),
            targetFreeDebtRatioStartBps,
            targetFreeDebtRatioEndBps
        ) returns (uint currBorrowRate, uint interest) {
            uint120 localReserveFee = uint120(interest * feeBps / 10000);
            uint120 globalReserveFee = uint120(interest * cachedGlobalFeeBps / 10000);
            accruedLocalReserves += localReserveFee;
            accruedGlobalReserves += globalReserveFee;
            // we remove reserve fees from interest before calculating how much to give to stakers
            uint interestAfterFees = interest - localReserveFee - globalReserveFee;
            uint totalStaked = coin.balanceOf(address(vault));
            if(totalStaked < totalPaidDebt) { // this also implies totalPaidDebt > 0 and guards the division below
                // if total staked is less than paid debt, giving all interest to stakers would
                // result in higher supply rate than borrow rate which is undesirable.
                // we cap the supply rate at the borrow rate and give the rest to local reserves.
                uint stakedInterest = interestAfterFees * totalStaked / totalPaidDebt;
                coin.mint(address(vault), stakedInterest);
                uint remainingInterest = interestAfterFees - stakedInterest;
                accruedLocalReserves += uint120(remainingInterest);
            } else {
                // if total staked is greater than paid debt, we give all interest to stakers
                coin.mint(address(vault), interestAfterFees);
            }
            totalPaidDebt += interest; // we add all interest to paid debt (NOT interestAfterFees)
            lastAccrue = uint40(block.timestamp);
            lastBorrowRateMantissa = uint88(currBorrowRate);
            cachedGlobalFeeBps = uint16(factory.getFeeOf(address(this)));
        } catch {
            // If the call failed, check if sufficient gas was provided
            // We need to ensure the caller provided enough gas for accrueInterest to execute
            require(gasBefore >= INTEREST_CALCULATION_GAS_REQUIREMENT, "Not enough gas for accrueInterest");
        }
    }

    function adjust(address account, int collateralDelta, int debtDelta) public {
        accrueInterest();
        updateBorrower(account);
        // Handle collateral changes
        if (collateralDelta > 0) {
            // Convert incoming collateral to internal 18 decimals
            uint256 collateralAmount = uint(collateralDelta);
            uint256 internalAmount = collateralToInternal(collateralAmount);
            
            if(!isRedeemable[account]) nonRedeemableCollateral += internalAmount;
            
            // Store in internal 18 decimals
            _cachedCollateralBalances[account] += internalAmount;
            collateralAmount = collateralDecimals > 18 ? internalToCollateral(internalAmount) : collateralAmount;
            // Transfer actual token amount
            collateral.safeTransferFrom(msg.sender, address(this), collateralAmount);
        } else if (collateralDelta < 0) {
            // Convert from internal 18 decimals to token decimals (rounds down)
            uint256 internalAmount = uint(-collateralDelta);
            uint256 collateralAmount = internalToCollateral(internalAmount);
            
            // Ensure sufficient collateral for non-redeemable accounts
            if (isRedeemable[account]) {
                // Calculate total redeemable in internal representation
                uint256 totalInternalCollateral = collateralToInternal(collateral.balanceOf(address(this)));
                require(
                    totalInternalCollateral - internalAmount >= nonRedeemableCollateral,
                    "Insufficient redeemable collateral"
                );
            } else {
                nonRedeemableCollateral -= internalAmount;
            }
 
            // Withdraw collateral (stored in internal representation)
            _cachedCollateralBalances[account] -= internalAmount;
            // Transfer actual token amount (rounded down)
            collateral.safeTransfer(msg.sender, collateralAmount);
        }

        // Handle debt changes
        int actualDebtDelta = debtDelta;
        if (debtDelta > 0) {
            // Borrow
            uint amount = uint256(debtDelta);
            increaseDebt(account, amount);
            coin.mint(msg.sender, amount);
        } else if (debtDelta < 0) {
            // Repay
            uint amount = uint256(-debtDelta);
            uint debt = getDebtOf(account);
            if(debt <= amount) {
                amount = debt;
                actualDebtDelta = -int(debt); // Use actual debt repaid for full repayment
                decreaseDebt(account, type(uint).max);
            } else {
                decreaseDebt(account, amount);
            }
            coin.transferFrom(msg.sender, address(this), amount);
            coin.burn(amount);
        }

        // if debtDelta is non-zero, require debt balance to either be 0 or >= minDebt
        uint debtBalance = getDebtOf(account);
        if(debtDelta != 0) require(debtBalance == 0 || debtBalance >= minDebt, "Debt below minimum and larger than 0");

        // Emit event before the first early return
        emit PositionAdjusted(account, collateralDelta, actualDebtDelta);

        // Skip remaining invariants if caller does not reduce collateral AND does not increase debt
        if(collateralDelta >= 0 && debtDelta <= 0) return;

        // The caller is removing collateral and/or increasing debt. Enforce ownership beyond this point
        require(msg.sender == account || delegations[account][msg.sender], "Unauthorized");

        // Skip solvency checks if debt is zero
        if(debtBalance == 0) return;

        // Check solvency
        (uint price, bool reduceOnly, ) = getCollateralPrice();
        require(!reduceOnly, "Reduce only");
        uint borrowingPower = price * _cachedCollateralBalances[account] * collateralFactor / 1e18 / 10000;
        require(debtBalance <= borrowingPower, "Solvency check failed");
    }

    function adjust(address account, int collateralDelta, int debtDelta, bool chooseRedeemable) external {
        setRedemptionStatus(account, chooseRedeemable);
        adjust(account, collateralDelta, debtDelta);
    }

    /// @notice Allows an account to delegate control of their position to another address (adjustPosition, optInRedemptions, optOutRedemptions functions)
    /// @param delegatee The address to delegate to
    /// @param isDelegatee True to enable delegation, false to revoke
    function delegate(address delegatee, bool isDelegatee) external {
        delegations[msg.sender][delegatee] = isDelegatee;
        emit DelegationUpdated(msg.sender, delegatee, isDelegatee);
    }

    function setRedemptionStatus(address account, bool chooseRedeemable) public {
        accrueInterest();
        updateBorrower(account);
        require(msg.sender == account || delegations[account][msg.sender], "Unauthorized");
        if(chooseRedeemable == isRedeemable[account]) return; // no change
        if(chooseRedeemable){
            borrowerEpoch[account] = epoch;
            borrowerLastRedeemedIndex[account] = epochRedeemedCollateral[epoch];
            nonRedeemableCollateral -= _cachedCollateralBalances[account];
        } else {
            nonRedeemableCollateral += _cachedCollateralBalances[account];
        }
        uint prevDebt = getDebtOf(account);
        if(prevDebt > 0) {
            decreaseDebt(account, type(uint).max);
            isRedeemable[account] = chooseRedeemable;
            increaseDebt(account, prevDebt);
            uint currDebt = getDebtOf(account);
            require(currDebt >= prevDebt, "Debt decreased unexpectedly");
        } else {
            isRedeemable[account] = chooseRedeemable;
        }
        emit RedemptionStatusUpdated(account, chooseRedeemable);
    }

        /// @notice Liquidates an unsafe position
    /// @param borrower The account to be liquidated
    /// @param repayAmount The amount of debt to repay
    /// @param minCollateralOut The minimum amount of collateral to receive (in token decimals)
    /// @return The amount of collateral received (in token decimals)
    function liquidate(address borrower, uint repayAmount, uint minCollateralOut) external returns(uint) {
        accrueInterest();
        updateBorrower(borrower);
        require(repayAmount > 0, "Repay amount must be greater than 0");
        (uint price,, bool allowLiquidations) = getCollateralPrice();
        require(allowLiquidations, "liquidations disabled");
        uint debt = getDebtOf(borrower);
        uint collateralBalance = _cachedCollateralBalances[borrower]; // in internal 18 decimals
        // check liquidation condition
        uint liquidatableDebt = getLiquidatableDebt(collateralBalance, price, debt);
        require(liquidatableDebt > 0, "insufficient liquidatable debt");
        if(repayAmount > liquidatableDebt) {
            repayAmount = liquidatableDebt;
        }

        // apply repayment
        decreaseDebt(borrower, repayAmount);

        // calculate collateral reward (in internal 18 decimals)
        uint liqIncentiveBps = getLiquidationIncentiveBps(collateralBalance, price, debt);
        uint collateralRewardValue = repayAmount * (10000 + liqIncentiveBps) / 10000;
        uint internalCollateralReward = collateralRewardValue * 1e18 / price;
        internalCollateralReward = internalCollateralReward > collateralBalance ? collateralBalance : internalCollateralReward;
        
        // Convert to token decimals for transfer (rounds down)
        uint collateralReward = internalToCollateral(internalCollateralReward);
        require(collateralReward >= minCollateralOut, "insufficient collateral out");

        if(internalCollateralReward > 0) {
            collateral.safeTransfer(msg.sender, collateralReward);
            _cachedCollateralBalances[borrower] = collateralBalance - internalCollateralReward;
            if(!isRedeemable[borrower]) nonRedeemableCollateral -= internalCollateralReward;
        }
        coin.transferFrom(msg.sender, address(this), repayAmount);
        coin.burn(repayAmount);
        emit Liquidated(borrower, msg.sender, repayAmount, collateralReward);
        
        uint256 gasBefore = gasleft();
        // try to write off remaining debt. Call externally and catch error to prevent liquidation failure
        try this.writeOff(borrower, msg.sender) {} catch {
            // If the call failed, check if sufficient gas was provided
            // We need to ensure the caller provided enough gas for writeOff to execute
            require(gasBefore >= WRITEOFF_GAS_REQUIREMENT, "Not enough gas for writeOff");
        }
        return collateralReward;
    }

    /// @notice Redistributes excess debt of undercollateralized accounts among other borrowers
    /// @param borrower The account in potentiallyundercollateralized state
    /// @return writtenOff True if the borrower was written off, false otherwise
    /// @param to The address to send the collateral to
    /// @dev This function is called by liquidate() when a borrower's position is undercollateralized. It should never revert to avoid liquidation failure.
    function writeOff(address borrower, address to) external returns (bool writtenOff) {
        accrueInterest();
        updateBorrower(borrower);
        // check for write off
        uint debt = getDebtOf(borrower);
        if(debt > 0) {
            uint collateralBalance = _cachedCollateralBalances[borrower]; // in internal 18 decimals
            (uint price,, bool allowLiquidations) = getCollateralPrice();
            require(allowLiquidations, "liquidations disabled");
            uint collateralValue = price * collateralBalance / 1e18;
            // if debt is more than 100 times the collateral value, write off
            if(debt > collateralValue * 100) {
                // 1. delete all of the borrower's debt
                decreaseDebt(borrower, type(uint).max);
                // 2. redistribute excess debt among remaining borrowers
                uint256 totalDebt = totalFreeDebt + totalPaidDebt;
                if (totalDebt > 0) {
                    uint256 freeDebtIncrease = debt * totalFreeDebt / totalDebt;
                    uint256 paidDebtIncrease = debt - freeDebtIncrease;

                    totalFreeDebt += freeDebtIncrease;
                    totalPaidDebt += paidDebtIncrease;
                }

                if(!isRedeemable[borrower]) nonRedeemableCollateral -= collateralBalance;
                _cachedCollateralBalances[borrower] = 0;
                
                // Convert to token decimals for transfer (rounds down)
                uint collateralAmount = internalToCollateral(collateralBalance);
                emit WrittenOff(borrower, to, debt, collateralAmount);
                writtenOff = true;
                
                // 3. send collateral to caller
                collateral.safeTransfer(to, collateralAmount);
            }
        }
    }

    /// @notice Redeems Coin for collateral at current market price minus a fee
    /// @param amountIn The amount of Coin to redeem
    /// @param minAmountOut The minimum amount of collateral to receive (in token decimals)
    /// @return amountOut The amount of collateral received (in token decimals)
    /// @dev Redemptions requires sufficient redeemable collateral to seize and free debt to repay
    function redeem(uint amountIn, uint minAmountOut) external returns (uint amountOut) {
        accrueInterest();
        // calculate amountOut in internal 18 decimals
        uint internalAmountOut = getRedeemAmountOut(amountIn);
        require(internalAmountOut > 0, "amount out is zero");
        // Convert to token decimals (rounds down)
        amountOut = internalToCollateral(internalAmountOut);
        require(amountOut >= minAmountOut, "insufficient amount out");
        
        // Check redeemable collateral in internal representation
        uint256 totalInternalCollateral = collateralToInternal(collateral.balanceOf(address(this)));
        require(totalInternalCollateral - internalAmountOut >= nonRedeemableCollateral, "Insufficient redeemable collateral");
        
        // repay on behalf of free debtors
        totalFreeDebt -= amountIn;
        coin.transferFrom(msg.sender, address(this), amountIn);
        coin.burn(amountIn);

        // distribute collateral redemption per free debt share (in internal representation)
        epochRedeemedCollateral[epoch] += internalAmountOut.mulDivUp(1e36, totalFreeDebtShares);

        collateral.safeTransfer(msg.sender, amountOut);

        // Intentional division by zero and revert if totalFreeDebt is 0
        if( totalFreeDebtShares / totalFreeDebt > 1e9) {
            epoch++;
            totalFreeDebtShares = totalFreeDebtShares.mulDivUp(1e18,1e36); 
            emit NewEpoch(epoch);
        }

        emit Redeemed(msg.sender, amountIn, amountOut);
        return amountOut;
    }

    function sell(uint coinIn, uint minAssetOut) external returns (uint assetOut) {
        require(psmAsset != ERC20(address(0)), "PSM asset was not set");
        accrueInterest();
        assetOut = getSellAmountOut(coinIn);
        require(assetOut >= minAssetOut, "insufficient amount out");
        // get and burn coins from caller
        coin.transferFrom(msg.sender, address(this), coinIn);
        coin.burn(coinIn);
        // give assets to caller
        if(psmVault != ERC4626(address(0))) {
            // Convert to shares out without taking into account fees, which will be paid by the seller by receiving less than assetOut
            uint256 sharesOut = psmVault.convertToShares(assetOut);
            uint256 actualAssetOutToSeller = psmVault.redeem(sharesOut, msg.sender, address(this));
            freePsmAssets -= assetOut;
            require(actualAssetOutToSeller >= minAssetOut, "redeem failed");
        } else {
            freePsmAssets -= assetOut;
            psmAsset.safeTransfer(msg.sender, assetOut);
        }
        emit Sold(msg.sender, coinIn, assetOut);
    }

    function buy(uint assetIn, uint minCoinOut) external beforeDeadline returns (uint coinOut) {
        require(psmAsset != ERC20(address(0)), "PSM asset was not set");
        accrueInterest();
        uint coinFee;
        (coinOut, coinFee) = getBuyAmountOut(assetIn);
        require(coinOut >= minCoinOut, "insufficient amount out");

        if(coinFee > 0) accruedLocalReserves += uint120(coinFee);

        // get assets from caller
        psmAsset.safeTransferFrom(msg.sender, address(this), assetIn);
        if(psmVault != ERC4626(address(0))) {
            require(psmVault.totalSupply() > minTotalSupply, "PSM vault total supply below minimum");
            uint256 shares = psmVault.deposit(assetIn, address(this));
            require(shares > 0, "PSM deposit failed");
            freePsmAssets += psmVault.previewRedeem(shares);
        } else {
            freePsmAssets += assetIn;
        }
        // give coins to caller
        coin.mint(msg.sender, coinOut);
        emit Bought(msg.sender, assetIn, coinOut);
    }

    function reapprovePsmVault() external beforeDeadline {
        if(psmVault != ERC4626(address(0)))
            psmAsset.approve(address(psmVault), type(uint).max);
    }

    // Internal functions

    function accruePsmProfit() internal {
        if(address(psmVault) != address(0)){
            uint assets = psmVault.previewRedeem(psmVault.balanceOf(address(this)));
            if(assets <= freePsmAssets) return; // avoids underflow in case of loss
            uint profit = assets - freePsmAssets;
            accruedLocalReserves += uint120(normalizePsmAssets(profit));
            freePsmAssets = assets;
        } else if(psmAsset != ERC20(address(0))) {
            // we do this in case the underlying asset may be a rebasing token that accrues profit
            uint bal = psmAsset.balanceOf(address(this));
            if(bal <= freePsmAssets) return; // avoids underflow in case of loss
            uint profit = bal - freePsmAssets;
            accruedLocalReserves += uint120(normalizePsmAssets(profit));
            freePsmAssets = bal;
        }
    }

    function updateBorrower(address borrower) internal {
        uint borrowerDebtShares = freeDebtShares[borrower];
        
        if (borrowerDebtShares > 0) {
            uint _borrowerEpoch = borrowerEpoch[borrower];
            uint bal = _cachedCollateralBalances[borrower];
            uint lastIndex = borrowerLastRedeemedIndex[borrower];
            // Loop through missed epochs (max 5 iterations considering max uint256 is 2^256 - 1 would go to zero in 5 iterations)
            for (uint i = 0; i < 5 && _borrowerEpoch < epoch && borrowerDebtShares > 0; ++i) {
                // Apply redemption for the borrower's current epoch
                uint indexDelta = epochRedeemedCollateral[_borrowerEpoch] - lastIndex;
                uint redeemedCollateral = indexDelta.mulDivUp(borrowerDebtShares, 1e36);
                bal = bal < redeemedCollateral ? 0 : bal - redeemedCollateral;

                // Move to next epoch, reduce shares
                _borrowerEpoch += 1;
                borrowerDebtShares = borrowerDebtShares.divWadUp(1e36) == 1 ? 0 : borrowerDebtShares.divWadUp(1e36); // If shares is 1 round down to 0
                lastIndex = 0; // For new epoch, last redeemed index is 0
            }
            // Apply any remaining redemption for the current epoch
            if (borrowerDebtShares > 0) {
                uint indexDelta = epochRedeemedCollateral[_borrowerEpoch] - lastIndex;
                uint redeemedCollateral = indexDelta.mulDivUp(borrowerDebtShares, 1e36);
                bal = bal < redeemedCollateral ? 0 : bal - redeemedCollateral;
            }
            // Update state
            freeDebtShares[borrower] = borrowerDebtShares;
            _cachedCollateralBalances[borrower] = bal;
        }

        if(isRedeemable[borrower]){
            borrowerEpoch[borrower] = epoch;
            borrowerLastRedeemedIndex[borrower] = epochRedeemedCollateral[epoch];
        } 
    }

    function increaseDebt(address account, uint256 amount) internal {
        if (isRedeemable[account]) {
            // Handle free debt
            uint shares = totalFreeDebt == 0 ? 
                    amount : 
                    amount.mulDivUp(totalFreeDebtShares, totalFreeDebt);
            
            // Update state first
            totalFreeDebt += amount;
            totalFreeDebtShares += shares;
            freeDebtShares[account] += shares;

            // Calculate actual debt increase after share conversion (in the new state)
            uint256 actualDebtIncrease = shares.mulDivUp(totalFreeDebt, totalFreeDebtShares);
            // Enforce max-delta guard: actual debt must not exceed requested by more than maxBorrowDeltaBps
            uint256 maxAllowedDebtIncrease = amount * (10000 + maxBorrowDeltaBps) / 10000;
            require(actualDebtIncrease <= maxAllowedDebtIncrease, "Borrow delta exceeds max");
        } else {
            // Handle paid debt 
            uint256 shares = totalPaidDebt == 0 ? 
                amount : 
                amount.mulDivUp(totalPaidDebtShares, totalPaidDebt);
            
            // Update state first
            totalPaidDebt += amount;
            totalPaidDebtShares += shares;
            paidDebtShares[account] += shares;
            
            // Calculate actual debt increase after share conversion (in the new state)
            uint256 actualDebtIncrease = shares.mulDivUp(totalPaidDebt, totalPaidDebtShares);
            // Enforce max-delta guard: actual debt must not exceed requested by more than maxBorrowDeltaBps
            uint256 maxAllowedDebtIncrease = amount * (10000 + maxBorrowDeltaBps) / 10000;
            require(actualDebtIncrease <= maxAllowedDebtIncrease, "Borrow delta exceeds max");
        }
    }

    function decreaseDebt(address account, uint256 amount) internal {
        if (isRedeemable[account]) {
            // Handle free debt
            uint256 shares;
            if(amount == type(uint).max) {
                shares = freeDebtShares[account];
                amount = getDebtOf(account);
            } else {
                shares = amount.mulDivDown(totalFreeDebtShares, totalFreeDebt);
            }
            freeDebtShares[account] -= shares;
            totalFreeDebtShares = totalFreeDebtShares <= shares ? 0 : totalFreeDebtShares - shares; // prevent underflow
            totalFreeDebt = totalFreeDebt <= amount ? 0 : totalFreeDebt - amount; // prevent underflow
        } else {
            // Handle paid debt
            uint256 shares;
            if(amount == type(uint).max) {
                shares = paidDebtShares[account];
                amount = getDebtOf(account);
            } else {
                shares = amount.mulDivDown(totalPaidDebtShares, totalPaidDebt);
            }
            
            paidDebtShares[account] -= shares;
            totalPaidDebtShares = totalPaidDebtShares <= shares ? 0 : totalPaidDebtShares - shares; // prevent underflow
            totalPaidDebt = totalPaidDebt <= amount ? 0 : totalPaidDebt - amount; // prevent underflow
        }
    }

    function getLiquidatableDebt(uint collateralBalance, uint price, uint debt) internal view returns(uint liquidatableDebt){
        uint borrowingPower = price * collateralBalance * collateralFactor / 1e18 / 10000;
        if(borrowingPower > debt) return 0;
        // liquidate 25% of the total debt
        liquidatableDebt = debt / 4; // 25% of the debt
        // liquidate at least MIN_LIQUIDATION_DEBT (or the entire debt if it's less than MIN_LIQUIDATION_DEBT)
        if(liquidatableDebt < MIN_LIQUIDATION_DEBT) liquidatableDebt = debt < MIN_LIQUIDATION_DEBT ? debt : MIN_LIQUIDATION_DEBT;
    }

    function getLiquidationIncentiveBps(uint collateralBalance, uint price, uint debt) internal view returns(uint) {
        uint collateralValue = collateralBalance * price / 1e18;
        if (collateralValue == 0) return 0; // avoid division by zero, return 0% incentive
        uint ltvBps = debt * 10000 / collateralValue;
        uint _collateralFactor = collateralFactor; // gas optimization
        uint maxLtvBps = _collateralFactor + 500; // range is [_collateralFactor, _collateralFactor + 5%]

        if (ltvBps <= _collateralFactor) {
            return 0; // 0% incentive
        } else if (ltvBps >= maxLtvBps) {
            return 1000; // 10% incentive
        } else {
            // linear interpolation between 0% and 10% incentive
            return (ltvBps - _collateralFactor) * 1000 / (maxLtvBps - _collateralFactor);
        }
    }

    // Getters

    function getFreeDebtRatio() public view returns (uint) {
        uint _adjustedTotalFreeDebt = totalFreeDebt + normalizePsmAssets(freePsmAssets);
        return _adjustedTotalFreeDebt == 0 ? 0 : _adjustedTotalFreeDebt * 10000 / (totalPaidDebt + _adjustedTotalFreeDebt);
    }

    function getDebtOf(address account) public view returns (uint) {
        if(isRedeemable[account]) {
            return totalFreeDebtShares == 0 ? 0 : freeDebtShares[account].mulDivUp(totalFreeDebt, totalFreeDebtShares);
        } else {
            return totalPaidDebtShares == 0 ? 0 : paidDebtShares[account].mulDivUp(totalPaidDebt, totalPaidDebtShares);
        }
    }

    /// @notice Gets the current price of the collateral asset
    /// @return price The price in USD normalized to (36 - collateral decimals) decimals for consistent calculations
    /// @return reduceOnly A boolean indicating if reduce only mode is enabled
    /// @return allowLiquidations A boolean indicating if liquidations and write-offs are enabled
    function getCollateralPrice() public view returns (uint price, bool reduceOnly, bool allowLiquidations) {
        uint updatedAt;
        allowLiquidations = true; // Default to allowing liquidations
        
        // call our own getFeedPrice() externally to catch all feed reverts e.g. due to inexistent feed contract, function, etc.
        try this.getFeedPrice() returns (uint _price, uint _updatedAt) {
            price = _price;
            updatedAt = _updatedAt;
            if(price == 0) {
                reduceOnly = true;
                allowLiquidations = false; // Disable liquidations if price is invalid
            }
        } catch {
            reduceOnly = true;
            allowLiquidations = false; // Disable liquidations only if the oracle feed is reverting
        }
        
        uint currentTime = block.timestamp;
        uint timeElapsed = currentTime >= updatedAt ? currentTime - updatedAt : 0;

        if (timeElapsed > stalenessThreshold) {
            reduceOnly = true;
            uint stalenessDuration = timeElapsed - stalenessThreshold;
            if (stalenessDuration < STALENESS_UNWIND_DURATION) {
                price = price * (STALENESS_UNWIND_DURATION - stalenessDuration) / STALENESS_UNWIND_DURATION;
            } else {
                price = 0;
            }
        }
        price = price == 0 ? 1 : price; // avoid division by zero in consumer functions
    }

    function getFeedPrice() external view returns (uint price, uint updatedAt) {
        (,int256 feedPrice,,uint256 feedUpdatedAt,) = feed.latestRoundData();
        uint8 feedDecimals = feed.decimals();
        uint8 tokenDecimals = 18; // we normalize to 18 decimals internally
        if(feedDecimals + tokenDecimals <= 36) {
            uint8 decimals = 36 - tokenDecimals - feedDecimals;
            price = feedPrice > 0 ? uint(feedPrice) * (10**decimals) : 0; // convert negative price to uint 0 to signal invalid price
        } else {
            uint8 decimals = feedDecimals + tokenDecimals - 36;
            price = feedPrice > 0 ? uint(feedPrice) / (10**decimals) : 0; // convert negative price to uint 0 to signal invalid price
        }
        updatedAt = feedUpdatedAt;
    }

    /// @notice Calculates the amount of collateral received for redeeming Coin
    /// @param amountIn The amount of Coin to redeem
    /// @return amountOut The amount of collateral to receive (in internal 18 decimals)
    function getRedeemAmountOut(uint amountIn) public view returns (uint amountOut) {
        if(amountIn > totalFreeDebt) return 0; // can't redeem more than free debt
        (uint price,, bool allowLiquidations) = getCollateralPrice();
        if(!allowLiquidations) return 0;
        // multiply amountIn by price then apply redeem fee to amountIn
        // Result is in internal 18 decimals
        amountOut = amountIn * 1e18 * (10000 - redeemFeeBps) / price / 10000;
    }

    function getSellAmountOut(uint coinIn) public view returns (uint assetOut) {
        uint8 coinDecimals = 18;
        uint8 assetDecimals = psmAsset.decimals();

        if (coinDecimals > assetDecimals) {
            // e.g., 18 decimals -> 6 decimals: divide by 10^(18-6) = 10^12
            assetOut = coinIn / (10 ** (coinDecimals - assetDecimals));
        } else if (assetDecimals > coinDecimals) {
            // e.g., 6 decimals -> 18 decimals: multiply by 10^(18-6) = 10^12
            assetOut = coinIn * (10 ** (assetDecimals - coinDecimals));
        } else {
            // Same decimals: 1:1 ratio
            assetOut = coinIn;
        }
    }

    function getBuyFeeBps() public view returns (uint) {
        uint startTime = deployTimestamp;
        uint deadline = immutabilityDeadline;
        uint current = block.timestamp;

        // Calculate the halfway point of the deadline period
        uint halfTime = startTime + ((deadline - startTime) / 2);

        if (current >= deadline || current < halfTime) {
            return 0;
        }

        // fee ramps from 0% to 1% (100 bps) over the second half of the deadline period
        // rampDuration = deadline - halfTime = (deadline - startTime) / 2
        // timeIntoRamp = current - halfTime
        // feeBps = timeIntoRamp * 100 / rampDuration
        uint rampDuration = deadline - halfTime;
        if (rampDuration == 0) return 100; // avoids division by zero

        uint timeIntoRamp = current - halfTime;
        uint buyFeeBps = timeIntoRamp * 100 / rampDuration;

        // Cap at 100 bps (1%)
        return buyFeeBps > 100 ? 100 : buyFeeBps;
    }

    function getBuyAmountOut(uint assetIn) public view returns (uint coinOut, uint coinFee) {
        uint8 coinDecimals = 18;
        uint8 assetDecimals = psmAsset.decimals();

        if (assetDecimals > coinDecimals) {
            // e.g., 6 decimals -> 18 decimals: divide by 10^(6-18) = 10^12
            coinOut = assetIn / (10 ** (assetDecimals - coinDecimals));
        } else if (coinDecimals > assetDecimals) {
            // e.g., 18 decimals -> 6 decimals: multiply by 10^(18-6) = 10^12
            coinOut = assetIn * (10 ** (coinDecimals - assetDecimals));
        } else {
            // Same decimals: 1:1 ratio
            coinOut = assetIn;
        }

        // Apply buy fee
        uint buyFeeBps = getBuyFeeBps();
        if(buyFeeBps > 0) {
            coinFee = coinOut * buyFeeBps / 10000;
            coinOut -= coinFee;
        }
    }

    /// @notice Normalizes PSM asset amount to 18 decimals
    /// @param assets The amount of PSM asset to normalize
    /// @return The normalized amount with 18 decimals
    function normalizePsmAssets(uint256 assets) internal view returns (uint256) {
        if (psmAssetDecimals == 18) {
            return assets;
        } else if (psmAssetDecimals > 18) {
            return assets / (10 ** (psmAssetDecimals - 18));
        } else {
            return assets * (10 ** (18 - psmAssetDecimals));
        }
    }

    /// @notice Converts collateral amount from token decimals to internal 18 decimals
    /// @param amount The amount in collateral token decimals
    /// @return The amount normalized to 18 decimals
    function collateralToInternal(uint256 amount) public view returns (uint256) {
        if (collateralDecimals == 18) {
            return amount;
        } else if (collateralDecimals > 18) {
            return amount / (10 ** (collateralDecimals - 18));
        } else {
            return amount * (10 ** (18 - collateralDecimals));
        }
    }

    /// @notice Converts collateral amount from internal 18 decimals to token decimals
    /// @param amount The amount in 18 decimals
    /// @return The amount in collateral token decimals
    function internalToCollateral(uint256 amount) public view returns (uint256) {
        if (collateralDecimals == 18) {
            return amount;
        } else if (collateralDecimals > 18) {
            return amount * (10 ** (collateralDecimals - 18));
        } else {
            return amount / (10 ** (18 - collateralDecimals));
        }
    }

    /// @notice Calculates the pending interest that would be earned by vault stakers if accrueInterest() were called
    /// @dev This is used by the Vault to include pending yield in totalAssets() for ERC-4626 compliance
    /// @return pendingVaultInterest The amount of interest that would be minted to the vault
    function getPendingInterest() external view returns (uint256 pendingVaultInterest) {
        uint timeElapsed = block.timestamp - lastAccrue;
        if(timeElapsed == 0) return 0;

        uint256 gasBefore = gasleft();
        
        try interestModel.calculateInterest(
            totalPaidDebt,
            lastBorrowRateMantissa,
            timeElapsed,
            expRate,
            getFreeDebtRatio(),
            targetFreeDebtRatioStartBps,
            targetFreeDebtRatioEndBps
        ) returns (uint, uint interest) {
            uint120 localReserveFee = uint120(interest * feeBps / 10000);
            uint120 globalReserveFee = uint120(interest * cachedGlobalFeeBps / 10000);
            // we remove reserve fees from interest before calculating how much to give to stakers
            uint interestAfterFees = interest - localReserveFee - globalReserveFee;
            uint totalStaked = coin.balanceOf(address(vault));
            if(totalStaked < totalPaidDebt) { // this also implies totalPaidDebt > 0 and guards the division below
                // if total staked is less than paid debt, giving all interest to stakers would
                // result in higher supply rate than borrow rate which is undesirable.
                // we cap the supply rate at the borrow rate and give the rest to local reserves.
                uint stakedInterest = interestAfterFees * totalStaked / totalPaidDebt;
                return stakedInterest;
            } else {
                // if total staked is greater than paid debt, we give all interest to stakers
                return interestAfterFees;
            }
        } catch {
            require(gasBefore >= INTEREST_CALCULATION_GAS_REQUIREMENT, "Not enough gas for accrueInterest");
        }
    }

    // Setters

    function setHalfLife(uint64 halfLife) external onlyOperatorOrManager beforeDeadline {
        accrueInterest();
        require(halfLife >= 12 hours && halfLife <= 30 days, "Invalid half life");
        expRate = uint64(uint(wadLn(2*1e18)) / halfLife);
        emit HalfLifeUpdated(halfLife);
    }

    function setTargetFreeDebtRatio(uint16 startBps, uint16 endBps) external onlyOperatorOrManager beforeDeadline {
        accrueInterest();
        require(startBps >= 500 && startBps <= endBps, "Invalid start bps");
        require(endBps >= startBps && endBps <= 9500, "Invalid end bps");
        targetFreeDebtRatioStartBps = uint16(startBps);
        targetFreeDebtRatioEndBps = uint16(endBps);
        emit TargetFreeDebtRatioUpdated(startBps, endBps);
    }

    function setRedeemFeeBps(uint16 _redeemFeeBps) external onlyOperatorOrManager beforeDeadline {
        accrueInterest();
        require(_redeemFeeBps <= 1000, "Invalid redeem fee bps");
        redeemFeeBps = uint16(_redeemFeeBps);
        emit RedeemFeeBpsUpdated(_redeemFeeBps);
    }

    function setMaxBorrowDeltaBps(uint16 _maxBorrowDeltaBps) external onlyOperatorOrManager beforeDeadline {
        require(_maxBorrowDeltaBps <= 200 && _maxBorrowDeltaBps >= 50, "Invalid borrow delta bps"); // Max 5%
        maxBorrowDeltaBps = _maxBorrowDeltaBps;
        emit MaxBorrowDeltaBpsUpdated(_maxBorrowDeltaBps);
    }

    function setLocalReserveFeeBps(uint _feeBps) external onlyOperator {
        accrueInterest();
        require(_feeBps <= 1000, "Invalid fee");
        feeBps = uint16(_feeBps);
        emit LocalReserveFeeUpdated(_feeBps);
    }

    function setPendingOperator(address _pendingOperator) external onlyOperator {
        pendingOperator = _pendingOperator;
        emit PendingOperatorUpdated(_pendingOperator);
    }

    function acceptOperator() external {
        require(msg.sender == pendingOperator, "Unauthorized");
        operator = pendingOperator;
        emit OperatorAccepted(pendingOperator);
    }

    function setManager(address _manager) external onlyOperatorOrManager {
        manager = _manager;
        emit ManagerUpdated(_manager);
    }

    function enableImmutabilityNow() external onlyOperator beforeDeadline {
        immutabilityDeadline = block.timestamp;
        emit ImmutabilityEnabled(block.timestamp);
    }

    function pullLocalReserves() external onlyOperator {
        accrueInterest();
        accruePsmProfit();
        coin.mint(msg.sender, accruedLocalReserves);
        emit AccruedLocalReserves(accruedLocalReserves);
        accruedLocalReserves = 0;
    }

    function pullGlobalReserves(address _to) external {
        require(msg.sender == address(factory), "Unauthorized");
        accrueInterest();
        coin.mint(_to, accruedGlobalReserves);
        emit AccruedGlobalReserves(accruedGlobalReserves);
        accruedGlobalReserves = 0;
    }

    // Events

    event PositionAdjusted(address indexed account, int collateralDelta, int debtDelta);
    event HalfLifeUpdated(uint64 halfLife);
    event TargetFreeDebtRatioUpdated(uint16 startBps, uint16 endBps);
    event RedeemFeeBpsUpdated(uint16 redeemFeeBps);
    event MaxBorrowDeltaBpsUpdated(uint16 maxBorrowDeltaBps);
    event DelegationUpdated(address indexed delegator, address indexed delegatee, bool isDelegatee);
    event PendingOperatorUpdated(address indexed pendingOperator);
    event OperatorAccepted(address indexed operator);
    event ManagerUpdated(address indexed manager);
    event LocalReserveFeeUpdated(uint256 feeBps);
    event RedemptionStatusUpdated(address indexed account, bool isRedeemable);
    event Liquidated(address indexed borrower, address indexed liquidator, uint repayAmount, uint collateralOut);
    event WrittenOff(address indexed borrower, address indexed to, uint debt, uint collateral);
    event NewEpoch(uint epoch);
    event Redeemed(address indexed account, uint amountIn, uint amountOut);
    event Sold(address indexed account, uint coinIn, uint assetOut);
    event Bought(address indexed account, uint assetIn, uint coinOut);
    event ImmutabilityEnabled(uint256 timestamp);
    event AccruedLocalReserves(uint256 amount);
    event AccruedGlobalReserves(uint256 amount);
}


// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import "lib/solmate/src/utils/SignedWadMath.sol";

// Only one instance of this contract is deployed for use by all Lender contracts
contract InterestModel {

    uint internal constant MIN_RATE = 5e15; // 0.5%

    // The reason why this pure math is called externally by Lender contracts even though
    // it is non-upgradeable is to allow Lender contracts try/catch the call for safety.
    // In case of unexpected under/overflow here, Lender contracts would skip accruing interest
    // while allowing borrowers to exit. Otherwise failure would freeze their funds.
    // We could have also added this as an external function to Lender and called
    // self.calculateInterest() externally, but since it's the same cost to call it here,
    // we opt for this approach in order to reduce contract bytecode size of Lender.
    // We also reduce Factory deployment costs by only using one instance of
    // this contract for all Lender contracts.
    function calculateInterest(
        uint _totalPaidDebt,
        uint _lastRate,
        uint _timeElapsed,
        uint _expRate,
        uint _lastFreeDebtRatioBps,
        uint _targetFreeDebtRatioStartBps,
        uint _targetFreeDebtRatioEndBps
    ) external pure returns (uint currBorrowRate, uint interest) {
        // check _expRate * _timeElapsed overflow
        if(uint(type(int256).max) / _expRate < _timeElapsed) _timeElapsed = uint(type(int256).max) / _expRate;
        // we use a negative exponent in order to prevent growthDecay overflow due to large timeElapsed
        // Results of positive exponents can exceed max uint256, negative exponents only return a value between [0, 1e18]
        uint growthDecay = uint(wadExp(-int(_expRate * _timeElapsed)));
        
        if (_lastFreeDebtRatioBps < _targetFreeDebtRatioStartBps) {
            currBorrowRate = _lastRate * 1e18 / growthDecay;
            interest = _totalPaidDebt * (currBorrowRate - _lastRate) / _expRate / 365 days;
        } else if (_lastFreeDebtRatioBps > _targetFreeDebtRatioEndBps) {
            currBorrowRate = _lastRate * growthDecay / 1e18;
            if (currBorrowRate < MIN_RATE) {
                currBorrowRate = MIN_RATE;
                // calculate integral
                if (_lastRate <= MIN_RATE) {
                    // Already at min rate, just use flat rate for entire period
                    interest = _totalPaidDebt * MIN_RATE * _timeElapsed / 365 days / 1e18;
                } else {
                    uint timeToMin = uint(-wadLn(int(MIN_RATE * 1e18 / _lastRate))) / _expRate;
                    // Decaying integral up to min rate, then add flat rate portion
                    interest = _totalPaidDebt * ((_lastRate - MIN_RATE) / _expRate + 
                              MIN_RATE * (_timeElapsed - timeToMin)) / 365 days / 1e18;
                }
            } else {
                interest = _totalPaidDebt * (_lastRate - currBorrowRate) / _expRate / 365 days;
            }
        } else {
            currBorrowRate = _lastRate;
            interest = _totalPaidDebt * _lastRate * _timeElapsed / 365 days / 1e18;
        }
        
        // If interest would overflow uint120 (cast in Lender), skip accrual
        // Also check if currBorrowRate would overflow uint88 (cast in Lender)
        if (interest > type(uint120).max || currBorrowRate > type(uint88).max) {
            return (_lastRate, 0);
        }
    }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import "./Lender.sol";

contract Lens {

    using FixedPointMathLib for uint256;
    

    function getCollateralOf(Lender _lender, address borrower) public view returns (uint256) {
        uint borrowerDebtShares = _lender.freeDebtShares(borrower);
        uint bal = _lender._cachedCollateralBalances(borrower);
        // If borrower has no free debt shares skip calculation and return cached balance
        if (borrowerDebtShares == 0) return _lender.internalToCollateral(bal);
        uint _borrowerEpoch = _lender.borrowerEpoch(borrower);
        uint lastIndex = _lender.borrowerLastRedeemedIndex(borrower);
        // Loop through all missed epochs
        for (uint i = 0; i < 5 && _borrowerEpoch < _lender.epoch() && borrowerDebtShares > 0; ++i) {
            // Apply redemption for the borrower's current epoch
            uint indexDelta = _lender.epochRedeemedCollateral(_borrowerEpoch) - lastIndex;
            uint redeemedCollateral = indexDelta.mulDivUp(borrowerDebtShares, 1e36);
            bal = bal < redeemedCollateral ? 0 : bal - redeemedCollateral;

            // Move to next epoch, reduce shares
            _borrowerEpoch += 1;
            borrowerDebtShares = borrowerDebtShares.divWadUp(1e36) == 1 ? 0 : borrowerDebtShares.divWadUp(1e36); // If shares is 1 round down to 0
            lastIndex = 0; // For new epoch, last redeemed index is 0
        }
        // Apply any remaining redemption for the current epoch
        if (borrowerDebtShares > 0) {
            uint indexDelta = _lender.epochRedeemedCollateral(_borrowerEpoch) - lastIndex;
            uint redeemedCollateral = indexDelta.mulDivUp(borrowerDebtShares, 1e36);
            bal = bal < redeemedCollateral ? 0 : bal - redeemedCollateral;
        }
        return _lender.internalToCollateral(bal);
    }

    /// @notice Returns the current debt of a borrower including accrued interest and accounting for redeemed debt
    /// @param _lender The Lender contract to query
    /// @param borrower The address of the borrower
    /// @return The current debt amount including all accrued interest and after accounting for redemptions
    function getDebtOf(Lender _lender, address borrower) public view returns (uint256) {
        // Get the current total debt including accrued interest
        (uint256 totalPaidDebt, uint256 totalFreeDebt) = _getSyncedTotalDebt(_lender);
        
        // Calculate the borrower's share of debt based on whether they are redeemable
        if (_lender.isRedeemable(borrower)) {
            // For redeemable (free) debt, we need to account for redemptions
            uint256 borrowerDebtShares = _lender.freeDebtShares(borrower);
            uint256 totalFreeDebtShares = _lender.totalFreeDebtShares();
            
            if (totalFreeDebtShares == 0) return 0;
            
            // Calculate base debt from shares
            uint256 debt = borrowerDebtShares.mulDivUp(totalFreeDebt, totalFreeDebtShares);
            
            // Account for debt reductions through redemptions
            // Similar to collateral redemptions, debt is reduced when redemptions occur
            uint256 _borrowerEpoch = _lender.borrowerEpoch(borrower);
            uint256 currentEpoch = _lender.epoch();
            
            // If borrower is in current epoch, no redemption adjustments needed
            // as redemptions reduce totalFreeDebt directly
            if (_borrowerEpoch < currentEpoch) {
                // Borrower missed epoch transitions, need to account for debt reductions
                // Each epoch transition reduces shares, which effectively reduces debt
                for (uint256 i = 0; i < 5 && _borrowerEpoch < currentEpoch && borrowerDebtShares > 0; ++i) {
                    _borrowerEpoch += 1;
                    borrowerDebtShares = borrowerDebtShares.divWadUp(1e36) == 1 ? 0 : borrowerDebtShares.divWadUp(1e36);
                }
                // Recalculate debt with reduced shares
                debt = totalFreeDebtShares == 0 ? 0 : borrowerDebtShares.mulDivUp(totalFreeDebt, totalFreeDebtShares);
            }
            
            return debt;
        } else {
            // For non-redeemable (paid) debt, simply calculate from shares with synced total
            uint256 paidDebtShares = _lender.paidDebtShares(borrower);
            uint256 totalPaidDebtShares = _lender.totalPaidDebtShares();
            
            return totalPaidDebtShares == 0 ? 0 : paidDebtShares.mulDivUp(totalPaidDebt, totalPaidDebtShares);
        }
    }

    /// @notice Internal helper to calculate total debt including accrued interest
    /// @param _lender The Lender contract to query
    /// @return syncedTotalPaidDebt The total paid debt including accrued interest
    /// @return syncedTotalFreeDebt The total free debt (redemptions already reduce this directly)
    function _getSyncedTotalDebt(Lender _lender) internal view returns (uint256 syncedTotalPaidDebt, uint256 syncedTotalFreeDebt) {
        uint256 totalPaidDebt = _lender.totalPaidDebt();
        syncedTotalFreeDebt = _lender.totalFreeDebt();
        
        // Calculate accrued interest since last accrual
        uint256 timeElapsed = block.timestamp - _lender.lastAccrue();
        
        if (timeElapsed == 0) {
            return (totalPaidDebt, syncedTotalFreeDebt);
        }
        
        // Call the interest model to calculate accrued interest
        try _lender.interestModel().calculateInterest(
            totalPaidDebt,
            _lender.lastBorrowRateMantissa(),
            timeElapsed,
            _lender.expRate(),
            _lender.getFreeDebtRatio(),
            _lender.targetFreeDebtRatioStartBps(),
            _lender.targetFreeDebtRatioEndBps()
        ) returns (uint256, uint256 interest) {
            // Add accrued interest to paid debt
            syncedTotalPaidDebt = totalPaidDebt + interest;
        } catch {
            // If interest calculation fails, return current totals
            syncedTotalPaidDebt = totalPaidDebt;
        }
    }
}