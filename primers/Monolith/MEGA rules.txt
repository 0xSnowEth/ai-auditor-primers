# COMPREHENSIVE MONOLITH AUDIT SCOPE GUIDE

## üö´ SECTION 1: ABSOLUTE OUT-OF-SCOPE (INSTANT INVALID)

### 1.1 TOKEN TYPES (EXPLICITLY EXCLUDED)

**‚ùå Fee-on-Transfer Tokens**
- **What:** Tokens that deduct fees during transfers (e.g., SAFEMOON)
- **Why Invalid:** Protocol documentation states: "Fee-on-transfer tokens are not supported"
- **Example Invalid Finding:** "Attacker deposits 100 FEE tokens, contract receives 98, but credits 100 ‚Üí 2 token profit"
- **How to Avoid:** Check if your attack requires non-standard ERC20 behavior

**‚ùå Rebasing Tokens**
- **What:** Tokens where balances change automatically (e.g., stETH, aToken)
- **Why Invalid:** "Rebasing tokens are not supported in the current version"
- **Example Invalid Finding:** "Flash loan of rebase token inflates balance ‚Üí share manipulation"
- **How to Avoid:** If your exploit mentions "rebase", "elastic supply", or "balance increases without transfer" ‚Üí STOP

**‚ùå ERC777 Reentrancy (Partially)**
- **What:** Tokens with callback hooks (`tokensReceived`)
- **Status:** ACKNOWLEDGED as risk, but protocol uses checks-effects-interactions
- **What's Invalid:** Generic ERC777 reentrancy without proving CEI pattern is broken
- **What's Valid:** Specific path where ERC777 callback can exploit state before update
- **How to Avoid:** Don't just say "ERC777 enables reentrancy" ‚Üí prove the exact vulnerable ordering

**‚ùå Extreme Decimal Tokens**
- **What:** Tokens with >30 decimals or <1 decimal
- **Why Invalid:** "Collateral tokens with very large/small decimals may cause exacerbated rounding errors"
- **Status:** Known issue, out of scope
- **Example Invalid Finding:** "Token with 50 decimals causes overflow in collateral calculation"
- **How to Avoid:** Assume collateral has 6-18 decimals (standard range)

**‚ùå Synthetic Asset Oracles with Extreme Prices**
- **What:** Oracles returning prices like 1e50 per token
- **Why Invalid:** "Synthetic asset oracles with very large price per token may cause rounding errors or not work well with global minimum debt floor"
- **Status:** Known issue, deployment parameter choice
- **How to Avoid:** Use realistic prices (e.g., $1-$100k per token)

---

### 1.2 OPERATOR/DEPLOYER TRUST ASSUMPTIONS

**‚ùå Malicious Oracle Deployment**
- **What:** Operator deploys with fake/malicious Chainlink feed
- **Why Invalid:** "Operators creating new Monolith Coins should be trusted to have set up a safe coin"
- **Example Invalid Finding:** "Operator can deploy with oracle that always returns 0 ‚Üí steal all collateral"
- **Status:** Explicitly out of scope - deployment safety is operator responsibility
- **How to Avoid:** Assume oracle, collateral, and PSM vault are SAFE at deployment

**‚ùå Malicious Collateral Token**
- **What:** Operator deploys with backdoored ERC20
- **Why Invalid:** Same as above - trusted deployment
- **Example Invalid Finding:** "Operator deploys with token that has mint() function ‚Üí infinite supply"
- **Status:** Out of scope
- **How to Avoid:** Assume collateral is standard, non-malicious ERC20

**‚ùå Malicious PSM Vault**
- **What:** Operator deploys with exploitable ERC4626 vault
- **Why Invalid:** "If the operator/deployer creates a Monolith coin with malicious/faulty collateral, oracle, or PSM vault... this is not considered a valid issue"
- **Status:** Explicitly excluded
- **How to Avoid:** Assume PSM vault is standard ERC4626

**‚úÖ EXCEPTION: Post-Deployment Parameter Manipulation**
- **What IS Valid:** "If changing parameters of the monolith coin allows them to steal user funds or nuke the price of the monolith coin, that can be viewed as a valid finding"
- **Example Valid Finding:** "Operator can set redeemFeeBps to 10000 (100%) after users deposit, stealing all redemptions"
- **Key Distinction:** 
  - ‚ùå Invalid: Malicious deployment (oracle/collateral/PSM)
  - ‚úÖ Valid: Parameter changes that enable theft AFTER safe deployment

---

### 1.3 EXTERNAL DEPENDENCIES (TRUST ASSUMPTIONS)

**‚ùå Chainlink Oracle Failures**
- **What:** Oracle stops updating, returns stale data, governance compromised
- **Why Invalid:** "We integrate primarily with Chainlink oracles and assume that Chainlink governance will operate correctly"
- **Example Invalid Finding:** "Chainlink oracle could return stale price ‚Üí liquidations fail"
- **Status:** Acknowledged - staleness checks are implemented as safety, but oracle trust is assumed
- **Nuance:** If you find staleness check is BROKEN, that's valid. But generic "oracle could be malicious" is invalid
- **How to Avoid:** Don't attack Chainlink's integrity; attack the protocol's HANDLING of oracle data

**‚ùå Bot/Keeper Delays or Failures**
- **What:** Liquidation bots don't act, redemption arbitrageurs delay, oracle updates slow
- **Why Invalid:** "Bot/oracle delays (not malice)" explicitly out of scope
- **Example Invalid Finding:** "If no one calls liquidate() for 24 hours, underwater positions remain"
- **Status:** Economic incentives assumed to work
- **How to Avoid:** Assume rational actors will liquidate/redeem when profitable

**‚ùå PSM Vault Governance Issues**
- **What:** Underlying ERC4626 vault's governance changes parameters maliciously
- **Why Invalid:** "For PSM integrations with other stablecoins or ERC4626 vaults, we trust the underlying protocol's governance"
- **Example Invalid Finding:** "PSM vault owner could set withdrawal fee to 100% ‚Üí trap funds"
- **Status:** Out of scope - governance trust assumed
- **How to Avoid:** Assume PSM vault governance is honest

---

### 1.4 SPECIFIC FUNCTION/CONTRACT EXCLUSIONS

**‚ùå Lens.sol Stale Views**
- **What:** Lens contract returns outdated debt/collateral values
- **Why Invalid:** "Lens.sol stale views" explicitly out of scope
- **Example Invalid Finding:** "Lens.getDebtOf() doesn't include latest interest ‚Üí UI shows wrong debt"
- **Status:** Lens is a VIEW helper, staleness is acceptable
- **How to Avoid:** Don't report view function staleness in Lens.sol

**‚ùå Vault.sol Zero Initial Deposit DoS**
- **What:** First depositor can manipulate share price with tiny deposit
- **Why Invalid:** "Vault.sol 0 initial deposits" explicitly out of scope
- **Status:** MIN_SHARES mechanism handles this
- **Example Invalid Finding:** "First depositor can deposit 1 wei, then donate 1M tokens ‚Üí inflate share price"
- **How to Avoid:** The MIN_SHARES (1e16) mechanism prevents this attack

**‚ùå Last Wei Division-by-Zero in Redemptions**
- **What:** When totalFreeDebt approaches 0, division could fail
- **Why Invalid:** "Div-by-zero in last wei redemption (intended)" out of scope
- **Example Invalid Finding:** "redeem() fails when totalFreeDebt = 1 due to division error"
- **Status:** Edge case, accepted by protocol
- **How to Avoid:** Don't report arithmetic issues in extreme low-liquidity scenarios

**‚ùå No Interest Rate Cap**
- **What:** Interest rate can theoretically go to infinity
- **Why Invalid:** "No rate cap (intended)" explicitly out of scope
- **Example Invalid Finding:** "Interest rate could exceed 1000% APY in extreme conditions"
- **Status:** Intended design - market-driven rates
- **How to Avoid:** Don't report unbounded interest rates as vulnerability

---

## üìã SECTION 2: PRIOR AUDIT FINDINGS (ALREADY FIXED/ACKNOWLEDGED)

### 2.1 FIXED ISSUES (DO NOT RESUBMIT)

**‚ùå Finding: accrueInterest() uninitialized lastAccrue**
- **What:** lastAccrue was 0 on first call
- **Status:** FIXED
- **How to Avoid:** Check `Lender.sol:219` - lastAccrue is initialized in constructor to `block.timestamp`

**‚ùå Finding: writeOff() locks collateral in Lender**
- **What:** Written-off collateral wasn't transferred to liquidator
- **Status:** FIXED
- **How to Avoid:** Check `Lender.sol:442` - collateral is now `safeTransfer`'d to `to` address

**‚ùå Finding: Oracle fallback price=1**
- **What:** When oracle fails, price defaults to 1 instead of reverting
- **Status:** FIXED  
- **How to Avoid:** Check `Lender.sol:695-712` - now properly handles reverts with reduce-only mode

**‚ùå Finding: getDebtOf() stale after epoch**
- **What:** Debt calculation didn't account for missed epoch transitions
- **Status:** FIXED
- **How to Avoid:** Check `Lender.sol:569-594` - `updateBorrower()` now loops through missed epochs

**‚ùå Finding: redeem() last wei div-by-zero**
- **What:** Redeeming final wei could cause division by zero
- **Status:** ACKNOWLEDGED (intentional edge case)
- **How to Avoid:** Don't report this - it's accepted behavior

**‚ùå Finding: No max interest rate**
- **What:** Interest rate unbounded
- **Status:** ACKNOWLEDGED (intended)
- **How to Avoid:** Don't report unbounded rates

**‚ùå Finding: Missing PositionAdjusted events**
- **What:** Events weren't emitted in all adjust() paths
- **Status:** FIXED
- **How to Avoid:** Check `Lender.sol:293` - event now emitted before early returns

**‚ùå Finding: liquidate() repayAmount UX**
- **What:** Confusing parameter naming
- **Status:** ACKNOWLEDGED (not a security issue)
- **How to Avoid:** Don't report naming/UX issues

**‚ùå Finding: Misleading comments/NatSpec**
- **What:** Documentation errors
- **Status:** ACKNOWLEDGED
- **How to Avoid:** Don't report documentation issues

**‚ùå Finding: balanceOf() in vault**
- **What:** Some confusion about balance tracking
- **Status:** FIXED
- **How to Avoid:** Review is complete, not a vulnerability

---

### 2.2 HOW TO VERIFY IF YOUR FINDING IS ALREADY FIXED

**Step-by-Step Process:**

1. **Check Constructor Initializations**
```solidity
// If your finding is about uninitialized variables, verify:
Lender.sol:219 ‚Üí lastAccrue = uint40(block.timestamp); // ‚úì Fixed
```

2. **Check Transfer Completeness**
```solidity
// If your finding is about locked funds, verify transfers exist:
Lender.sol:442 ‚Üí collateral.safeTransfer(to, collateralAmount); // ‚úì Fixed
```

3. **Check Event Emissions**
```solidity
// If your finding is about missing events, verify:
Lender.sol:293 ‚Üí emit PositionAdjusted(...); // ‚úì Fixed
```

4. **Check Loop Handling**
```solidity
// If your finding is about missed state updates, verify loops:
Lender.sol:573-582 ‚Üí for (uint i = 0; i < 5 && ...) // ‚úì Fixed
```

---

## üéØ SECTION 3: COMMON MISUNDERSTANDINGS TO AVOID

### 3.1 ARCHITECTURE MISUNDERSTANDINGS

**‚ùå MISUNDERSTANDING: "Vault stores collateral"**
- **Reality:** 
  - `Vault.sol` = ERC4626 vault for staking **Coin tokens** (the stablecoin)
  - Collateral is held directly in `Lender.sol`
- **Why This Matters:** Many invalid findings confuse these two
- **Example Invalid:** "Flash loan manipulates Vault collateral balance"
- **Correct Understanding:** Vault has nothing to do with collateral; it's for Coin staking

**‚ùå MISUNDERSTANDING: "ERC4626 share inflation works here"**
- **Reality:** Standard ERC4626 inflation requires:
  1. Initial deposit = 1 wei (BLOCKED by MIN_SHARES = 1e16)
  2. Direct donation to vault (doesn't help due to MIN_SHARES burn)
  3. First depositor advantage (BLOCKED by MIN_SHARES mechanism)
- **Example Invalid:** "First depositor deposits 1 wei, donates 1M, profits from inflation"
- **Correct Understanding:** MIN_SHARES = 1e16 (0.01 Coin) prevents inflation attacks

**‚ùå MISUNDERSTANDING: "PSM sell() bug enables theft"**
- **Reality:** `sell()` missing `accruePsmProfit()` is in EXCLUDED FINDINGS
- **Why:** Already found, validated, confirmed in your own exclusion list
- **Example Invalid:** "sell() doesn't accrue profit ‚Üí user steals yield"
- **Correct Understanding:** This is Finding #2 in your exclusion document ‚Üí DON'T RESUBMIT

**‚ùå MISUNDERSTANDING: "Share dilution via rounding accumulates infinitely"**
- **Reality:** `maxBorrowDeltaBps` caps per-operation rounding
- **Why This Matters:** Excluded Finding #3 already covers asymmetric rounding
- **Example Invalid:** "User can switch redemption status 1000 times ‚Üí 10% dilution"
- **Correct Understanding:** 
  - This is already in exclusions as "Debt Share Price Erosion"
  - Each operation capped at 0.5-2% error
  - Requires proof of bypassing the cap, not just accumulation within cap

**‚ùå MISUNDERSTANDING: "Interest calculation can underflow"**
- **Reality:** wadExp underflow is in EXCLUDED FINDINGS
- **Why:** Already found, validated, confirmed (Excluded Finding #4)
- **Example Invalid:** "After 6 months inactivity, wadExp returns 0 ‚Üí division by zero"
- **Correct Understanding:** This is "Interest Accrual Skipped via Division by Zero" ‚Üí DON'T RESUBMIT

---

### 3.2 ERC4626 MECHANICS MISUNDERSTANDINGS

**‚ùå MISUNDERSTANDING: "Higher totalAssets = cheaper shares"**
- **Reality:** **OPPOSITE** - Higher totalAssets = MORE EXPENSIVE shares
- **Math:**
  ```
  shares = assets * totalSupply / totalAssets
  
  If totalAssets increases:
  - Denominator increases
  - Shares per asset DECREASES
  - Shares become MORE expensive
  ```
- **Example Invalid:** "Flash loan increases totalAssets ‚Üí attacker mints cheap shares"
- **Correct Math:** Flash loan makes shares EXPENSIVE, attacker gets FEWER shares per coin

**‚ùå MISUNDERSTANDING: "totalSupply manipulation profits attacker"**
- **Reality:** Attacker dilutes themselves
- **Example Invalid:** "Attacker deposits 1M, mints lots of shares, profits"
- **Correct Understanding:** 
  - Attacker deposits 1M ‚Üí mints shares proportional to contribution
  - Other users unaffected (their share % stays same)
  - Attacker gains nothing

**‚ùå MISUNDERSTANDING: "Events mismatch = HIGH severity"**
- **Reality:** Event bugs are typically LOW/MEDIUM unless they cause state corruption
- **Example:** "Deposit event emits wrong share amount" = MEDIUM (EIP violation), not HIGH
- **Why:** Events don't affect on-chain state, only off-chain indexers
- **Valid Severity:** MEDIUM for EIP MUST violations, LOW otherwise

---

### 3.3 DECIMAL CONVERSION MISUNDERSTANDINGS

**‚ùå MISUNDERSTANDING: "Decimal conversion always rounds against protocol"**
- **Reality:** Protocol uses explicit rounding directions
- **Check These Functions:**
  ```solidity
  collateralToInternal() // Normalizes collateral ‚Üí 18 decimals
  internalToCollateral() // Denormalizes 18 decimals ‚Üí collateral
  normalizePsmAssets()   // Normalizes PSM asset ‚Üí 18 decimals
  ```
- **Example Invalid:** "6-decimal USDC converts to 18 decimals, rounding allows theft"
- **Correct Understanding:** Rounding DOWN on withdrawals protects protocol

**‚ùå MISUNDERSTANDING: "Truncation = vulnerability"**
- **Reality:** Integer division truncation is expected and safe
- **Example Invalid:** "internalToCollateral() truncates, user loses 0.000001 tokens"
- **Correct Understanding:** 
  - Truncation is intentional (rounds down withdrawals)
  - User can't extract unowned funds
  - Invariant "dust remains in protocol" is acceptable

---

### 3.4 LIQUIDATION MECHANICS MISUNDERSTANDINGS

**‚ùå MISUNDERSTANDING: "Liquidator can liquidate 100% of debt"**
- **Reality:** Max 25% per liquidation (see `getLiquidatableDebt`)
- **Code:**
  ```solidity
  liquidatableDebt = debt / 4; // 25% of debt
  if(liquidatableDebt < MIN_LIQUIDATION_DEBT) 
      liquidatableDebt = min(debt, MIN_LIQUIDATION_DEBT);
  ```
- **Example Invalid:** "Liquidator can drain entire position in one call"
- **Correct Understanding:** Requires multiple liquidations to fully liquidate

**‚ùå MISUNDERSTANDING: "Liquidation incentive is fixed"**
- **Reality:** Incentive is dynamic (0-10% based on LTV)
- **Code:** `getLiquidationIncentiveBps()` - linear interpolation from collateralFactor to collateralFactor+5%
- **Example Invalid:** "Liquidator always gets 10% bonus"
- **Correct Understanding:** Bonus increases as position becomes more underwater

**‚ùå MISUNDERSTANDING: "writeOff() is a backdoor"**
- **Reality:** writeOff() socializes bad debt (debt > collateral √ó 100)
- **When It Triggers:** Only when `debt > collateralValue * 100`
- **What It Does:** 
  1. Deletes borrower's debt
  2. Redistributes debt to all other borrowers proportionally
  3. Sends remaining collateral to caller
- **Example Invalid:** "Attacker can call writeOff to steal any position"
- **Correct Understanding:** Only triggers for positions with 100:1 debt-to-collateral ratio

---

### 3.5 REDEMPTION MECHANICS MISUNDERSTANDINGS

**‚ùå MISUNDERSTANDING: "Redemptions directly reduce borrower collateral"**
- **Reality:** Redemptions update `epochRedeemedCollateral`, collateral deducted on next `updateBorrower()` call
- **Flow:**
  ```
  1. redeem() updates epochRedeemedCollateral[epoch] (index accumulator)
  2. User calls adjust()/liquidate()/etc
  3. updateBorrower() applies accumulated redemptions
  4. Collateral balance reduced
  ```
- **Example Invalid:** "Borrower can frontrun redemption to avoid collateral loss"
- **Correct Understanding:** Collateral loss is delayed but guaranteed once redemption processes

**‚ùå MISUNDERSTANDING: "Non-redeemable borrowers can be redeemed against"**
- **Reality:** Only FREE debt (redeemable) is subject to redemptions
- **Two Debt Pools:**
  - Paid debt (non-redeemable): Accrues interest, never redeemed
  - Free debt (redeemable): No interest, subject to redemptions
- **Example Invalid:** "Redemption steals collateral from paid debt borrowers"
- **Correct Understanding:** `redeem()` only affects `totalFreeDebt` borrowers

**‚ùå MISUNDERSTANDING: "Epoch transitions are exploitable"**
- **Reality:** Epochs reset shares proportionally
- **Trigger:** When `totalFreeDebtShares / totalFreeDebt > 1e9`
- **What Happens:** `totalFreeDebtShares = totalFreeDebtShares * 1e18 / 1e36` (reduces by 1e18)
- **Example Invalid:** "Attacker forces epoch transitions to dilute other borrowers"
- **Correct Understanding:** Everyone's shares reduce proportionally, no advantage

---

### 3.6 INTEREST RATE MECHANICS MISUNDERSTANDINGS

**‚ùå MISUNDERSTANDING: "Interest rate controller can be manipulated"**
- **Reality:** Rate adjusts based on free debt ratio, autonomous and fair
- **Formula:**
  ```
  If freeDebtRatio < startBps: Rate increases exponentially
  If freeDebtRatio > endBps: Rate decreases exponentially  
  Else: Rate stays constant
  ```
- **Example Invalid:** "Attacker manipulates freeDebtRatio to force high rates"
- **Correct Understanding:** Anyone manipulating ratio pays the price themselves (high/low rates affect all)

**‚ùå MISUNDERSTANDING: "accrueInterest() failure = loss of yield"**
- **Reality:** This is EXCLUDED FINDING #4
- **Status:** Already validated and excluded from submission
- **Example Invalid:** "When calculateInterest() reverts, interest is lost forever"
- **Correct Understanding:** This is the "wadExp underflow" issue ‚Üí DON'T RESUBMIT

---

## ‚úÖ SECTION 4: WHAT IS ACTUALLY IN SCOPE

### 4.1 VALID VULNERABILITY CATEGORIES

**‚úÖ CATEGORY 1: State Corruption**
- **What:** Exploits that break internal accounting invariants
- **Examples:**
  - Total debt < sum of individual debts
  - Collateral balance mismatch between `_cachedCollateralBalances` and actual holdings
  - Share dilution that violates "share price never decreases" invariant
- **How to Prove:**
  1. Show initial state (invariant holds)
  2. Show exploit tx sequence
  3. Show final state (invariant broken)
  4. Demonstrate economic loss

**‚úÖ CATEGORY 2: Unauthorized Fund Extraction**
- **What:** Stealing funds without proper authorization
- **Examples:**
  - Withdrawing collateral beyond what you own
  - Minting Coin without collateral backing
  - Extracting PSM reserves beyond your share
- **Requirements:**
  - Assumes SAFE deployment (good oracle, good collateral)
  - Exploit works through protocol logic, not malicious tokens
- **How to Prove:**
  1. Show attacker's initial balance
  2. Show exploit sequence
  3. Show attacker's final balance > initial balance + legitimate earnings

**‚úÖ CATEGORY 3: Liquidation Bypass**
- **What:** Preventing liquidations of underwater positions
- **Examples:**
  - Position with LTV > collateralFactor can't be liquidated
  - Liquidation function reverts for valid liquidations
  - Borrower can block liquidation through reentrancy
- **Requirements:**
  - Must be exploitable with standard ERC20 (not ERC777 unless you prove CEI break)
  - Oracle is functioning normally
- **How to Prove:**
  1. Create underwater position (debt > collateralFactor √ó collateral √ó price)
  2. Show liquidate() fails or can be blocked
  3. Demonstrate economic harm (bad debt accumulates)

**‚úÖ CATEGORY 4: Oracle Manipulation**
- **What:** Manipulating the protocol's HANDLING of oracle data (not Chainlink itself)
- **Examples:**
  - Staleness check can be bypassed
  - Reduce-only mode can be triggered maliciously
  - Price precision loss causes exploitable rounding
- **Invalid Examples:**
  - "Chainlink oracle could be compromised" ‚Üí OUT OF SCOPE
  - "Chainlink could return stale data" ‚Üí ACKNOWLEDGED, staleness checks exist
- **How to Prove:**
  1. Show normal oracle state
  2. Show how attacker manipulates protocol's REACTION to oracle
  3. Demonstrate profit or system failure

**‚úÖ CATEGORY 5: PSM Economic Exploits**
- **What:** Extracting value from PSM beyond your contribution
- **Examples:**
  - Manipulating buy/sell to extract yield
  - Arbitraging buy fee ramping for profit
  - Exploiting vault share mechanics
- **Invalid Examples:**
  - "sell() doesn't accrue profit" ‚Üí EXCLUDED FINDING #2
  - "PSM vault governance changes" ‚Üí OUT OF SCOPE
- **How to Prove:**
  1. Show initial PSM state (reserves, freePsmAssets)
  2. Show exploit sequence
  3. Show final state with extracted value
  4. Calculate profit > gas costs

**‚úÖ CATEGORY 6: Parameter Manipulation by Operator**
- **What:** Operator changes parameters AFTER safe deployment to steal/harm users
- **Examples:**
  - Setting redeemFeeBps to 10000 (100%) after users borrow
  - Setting collateralFactor to 0 to force all liquidations
  - Setting feeBps to 10000 to steal all interest
- **Requirements:**
  - Assumes INITIAL deployment was safe
  - Parameter change enables NEW attack vector
- **How to Prove:**
  1. Show safe initial state
  2. Show operator parameter change
  3. Show how this enables theft/harm
  4. Demonstrate users lose funds

**‚úÖ CATEGORY 7: Reentrancy (Specific Paths Only)**
- **What:** Exploitable reentrancy despite checks-effects-interactions pattern
- **Requirements:**
  - Must prove SPECIFIC function where state is read before update
  - Must work with standard ERC20 (or prove ERC777 breaks CEI)
  - Can't just claim "reentrancy possible" without exploit path
- **Example Valid:**
  ```solidity
  function vulnerable() external {
      uint amount = calculateBasedOnState(); // reads state
      token.safeTransfer(msg.sender, amount); // if token is ERC777
      state = newState; // updates state AFTER transfer
  }
  ```
- **Example Invalid:**
  ```solidity
  function safe() external {
      state = newState; // updates BEFORE transfer
      token.safeTransfer(msg.sender, amount);
  }
  ```

**‚úÖ CATEGORY 8: EIP Compliance Violations**
- **What:** Breaking EIP MUST requirements
- **Severity:** MEDIUM (as per audit driver)
- **Examples:**
  - ERC20: Transfer returns false instead of reverting
  - ERC4626: previewDeposit doesn't match actual deposit
  - Chainlink: latestRoundData doesn't check roundId
- **How to Prove:**
  1. Quote exact EIP MUST statement
  2. Show code violating it
  3. Demonstrate impact (even if low, still MEDIUM per rules)

---

### 4.2 CRITICAL INVARIANTS TO TEST

**INVARIANT 1: Total collateral ‚â• sum(user collateral)**
```solidity
// Must ALWAYS hold:
collateral.balanceOf(address(lender)) >= 
    sum of all lender._cachedCollateralBalances(user)
```
- **How to Break:** Find a way to withdraw more than you deposited
- **How to Test:**
  1. Track `sum(_cachedCollateralBalances)` before action
  2. Perform action
  3. Verify `balanceOf >= sum(_cachedCollateralBalances)` still holds

**INVARIANT 2: Total debt ‚â• circulating Coin (excl PSM)**
```solidity
// Must ALWAYS hold:
lender.totalFreeDebt + lender.totalPaidDebt >= 
    coin.totalSupply - freePsmAssets
```
- **How to Break:** Mint Coin without increasing debt
- **How to Test:**
  1. Track debt before action
  2. Perform action
  3. Verify supply increase ‚â§ debt increase

**INVARIANT 3: Debt share price never decreases (except writeOff)**
```solidity
// For paid debt:
(totalPaidDebt / totalPaidDebtShares) must be monotonically increasing

// For free debt:
(totalFreeDebt / totalFreeDebtShares) must be monotonically increasing
```
- **Status:** Asymmetric rounding IS in exclusions, but if you find NEW vector, valid
- **How to Break:** Find state transition where sharePrice(t+1) < sharePrice(t)
- **How to Test:**
  1. Calculate sharePrice = totalDebt / totalShares
  2. Perform action
  3. Verify new sharePrice >= old sharePrice

**INVARIANT 4: PSM reserves ‚â• PSM-backed Coin**
```solidity
// Must ALWAYS hold:
freePsmAssets >= 0 (never negative)
psmAsset.balanceOf(lender) >= freePsmAssets (or vault equivalent)
```
- **How to Break:** Sell more than reserves, or drain reserves without burning Coin
- **How to Test:**
  1. Track freePsmAssets before action
  2. Perform sell/buy
  3. Verify reserves still cover freePsmAssets

**INVARIANT 5: Undercollateralized positions always liquidatable**
```solidity
// If debt > borrowingPower, must be liquidatable:
if (debt > price * collateral * collateralFactor / 1e18 / 10000) {
    // liquidate() must succeed
}
```
- **How to Break:** Create underwater position that can't be liquidated
- **How to Test:**
  1. Create position
  2. Change price to make underwater
  3. Attempt liquidation
  4. Verify liquidation succeeds

**INVARIANT 6: Interest accrues correctly over time**
```solidity
// After time T, totalPaidDebt should increase by expected interest
expectedInterest = totalPaidDebt * rate * T / 365 days / 1e18
```
- **Status:** wadExp underflow IS in exclusions, but if you find NEW vector, valid
- **How to Break:** Skip interest accrual without catching it
- **How to Test:**
  1. Record totalPaidDebt at t0
  2. Wait time T
  3. Call accrueInterest()
  4. Verify totalPaidDebt increased by ‚âàexpectedInterest

**INVARIANT 7: Redemptions reduce free borrower collateral proportionally**
```solidity
// After redemption, each free borrower loses:
collateralLoss = amountRedeemed * (borrowerShares / totalFreeDebtShares)
```
- **How to Break:** Borrower avoids collateral loss during redemption
- **How to Test:**
  1. Track borrower collateral before redeem
  2. Perform redemption
  3. Call updateBorrower()
  4. Verify collateral reduced proportionally

**INVARIANT 8: nonRedeemableCollateral ‚â• sum(non-redeemable users)**
```solidity
// Must ALWAYS hold:
lender.nonRedeemableCollateral == 
    sum of _cachedCollateralBalances for all users where isRedeemable[user] == false
```
- **How to Break:** Make nonRedeemableCollateral diverge from actual sum
- **How to Test:**
  1. Create multiple redeemable/non-redeemable borrowers
  2. Perform actions (redeem, switch status, etc)
  3. Calculate actual sum
  4. Verify equals nonRedeemableCollateral

**INVARIANT 9: Debt rounded UP in favor of protocol**
```solidity
// When calculating debt from shares:
debt = shares.mulDivUp(totalDebt, totalShares) // rounds UP
```
- **How to Break:** Find calculation that rounds down, giving free Coin
- **How to Test:**
  1. Create position with shares that would round
  2. Calculate debt
  3. Verify rounds in protocol's favor (user pays more, not less)

---

## üîç SECTION 5: VALIDATION CHECKLIST FOR YOUR FINDINGS

### 5.1 BEFORE YOU SUBMIT - ASK THESE QUESTIONS

**QUESTION 1: Is my attack vector in the exclusion lists?**
- [ ] Not in OUT OF SCOPE section (rebasing, fee-on-transfer, malicious deployment)
- [ ] Not in PRIOR AUDIT findings (accrueInterest, writeOff, etc)
- [ ] Not in EXCLUDED FINDINGS (PSM sell asymmetry, share erosion, wadExp underflow)
- [ ] Not a misunderstanding (confusing Vault with collateral, backward ERC4626 math)

**QUESTION 2: Have I verified my code references?**
- [ ] File name is correct
- [ ] Line numbers are correct
- [ ] Function name is correct
- [ ] Function actually does what I claim it does

**QUESTION 3: Does my math add up?**
- [ ] Calculated profit is positive (attacker gains, not loses)
- [ ] Rounding direction is what I claim
- [ ] Share price moves in claimed direction
- [ ] All decimal conversions are correct

**QUESTION 4: Is my exploit actually executable?**
- [ ] No circular dependencies ("need to borrow to provide collateral to borrow")
- [ ] No impossible sequences ("flash loan during reentrancy callback of function that doesn't callback")
- [ ] No magic ("assume attacker controls oracle" when oracle is Chainlink)
- [ ] Can execute on standard ERC20 (or prove ERC777 is exploitable)

**QUESTION 5: Does my finding break an invariant?**
- [ ] Directly violates one of INV-1 through INV-9
- [ ] Can prove with before/after state comparison
- [ ] Economic impact is demonstrable
- [ ] Not just "could theoretically happen" but "WILL happen with these steps"

**QUESTION 6: Have I provided a complete exploit path?**
- [ ] Step 1: Initial state clearly defined
- [ ] Step 2-N: Every transaction clearly specified (function, parameters, sender)
- [ ] Final state: Clearly show attacker profit or system failure
- [ ] No hand-waving ("attacker somehow gets X") - every step explicit

**QUESTION 7: Is my severity justified?**
- [ ] HIGH: Direct fund loss, protocol insolvency, complete DoS
- [ ] MEDIUM: Indirect loss, temporary DoS, EIP violation, parameter manipulation harm
- [ ] LOW: Edge case, minor accounting discrepancy, cosmetic issues
- [ ] Not confusing "could affect many users" with severity (that's scale, not severity)

---

### 5.2 RED FLAGS THAT INDICATE INVALID FINDING

**üö© RED FLAG 1: "Flash loan increases balance ‚Üí profit"**
- **Why Invalid:** Flash loans are neutral (borrow and repay same tx)
- **Check:** Does your exploit actually show NET profit AFTER repaying flash loan?

**üö© RED FLAG 2: "Reentrancy via standard ERC20 transfer"**
- **Why Invalid:** ERC20.transfer has no callback
- **Check:** Are you assuming ERC777? Did you prove CEI pattern is broken?

**üö© RED FLAG 3: "Operator can deploy malicious X"**
- **Why Invalid:** Deployment trust is assumed
- **Check:** Is your exploit about DEPLOYMENT or POST-DEPLOYMENT parameters?

**üö© RED FLAG 4: "Oracle could return malicious data"**
- **Why Invalid:** Chainlink trust is assumed
- **Check:** Is your exploit about oracle INTEGRITY or protocol's HANDLING of data?

**üö© RED FLAG 5: "View function returns stale data"**
- **Why Invalid:** View function staleness is acceptable
- **Check:** Does stale data cause STATE CORRUPTION or just UI issues?

**üö© RED FLAG 6: "Shares become cheaper when totalAssets increases"**
- **Why Invalid:** Backward math (shares become MORE expensive)
- **Check:** Did you actually run the division? shares = assets √ó supply / totalAssets

**üö© RED FLAG 7: "First depositor can manipulate share price"**
- **Why Invalid:** MIN_SHARES = 1e16 prevents this
- **Check:** Did you account for MIN_SHARES burn on first deposit?

**üö© RED FLAG 8: "Interest rate can go to infinity"**
- **Why Invalid:** "No rate cap" is out of scope
- **Check:** Is your issue the LACK of cap or EXPLOITATION of unbounded rate?

**üö© RED FLAG 9: "Attacker can call writeOff() on any position"**
- **Why Invalid:** writeOff only works when debt > collateralValue √ó 100
- **Check:** Does target position actually meet writeOff threshold?

**üö© RED FLAG 10: "Events emit wrong values"**
- **Why Invalid:** Events don't affect state unless you prove state relies on events
- **Check:** Does event mismatch cause STATE CORRUPTION or just indexer confusion?

---

## üéì SECTION 6: RESEARCH METHODOLOGY

### 6.1 HOW TO FIND VALID BUGS

**STEP 1: Read the Code (Don't Pattern Match)**
```
‚ùå Wrong: "This is ERC4626 ‚Üí check for inflation attack"
‚úÖ Right: "This is ERC4626 with MIN_SHARES ‚Üí inflation prevented, what else could break?"
```

**STEP 2: Test Your Assumptions**
```
‚ùå Wrong: "Flash loan increases balance ‚Üí shares cheaper ‚Üí profit"
‚úÖ Right: "Let me calculate: shares = 1000 * 1000 / 1,001,000 = 0.999... wait, that's FEWER shares"
```

**STEP 3: Trace Full Transaction Flow**
```
‚ùå Wrong: "Function X calls Y which is vulnerable"
‚úÖ Right: "Function X calls Y which updates state, then Z, then returns. Where exactly is vulnerability?"
```

**STEP 4: Write Proof of Concept**
```
‚ùå Wrong: "Attacker can exploit this, here's the theory"
‚úÖ Right: "Here's the Foundry test showing exact state before/after with profit calculation"
```

**STEP 5: Check Against Exclusions**
```
‚ùå Wrong: "I found something ‚Üí submit immediately"
‚úÖ Right: "I found something ‚Üí check 5 exclusion lists ‚Üí still unique ‚Üí submit"
```

---

### 6.2 COMMON AUDIT PATTERNS (USE THESE)

**PATTERN 1: Decimal Conversion Attacks**
- **Where:** Functions that convert between token decimals and internal 18 decimals
- **Look For:**
  - Rounding that benefits attacker
  - Precision loss that accumulates
  - Conversion order that allows manipulation
- **Functions to Check:**
  - `collateralToInternal()`
  - `internalToCollateral()`
  - `normalizePsmAssets()`
  - Any math involving `10 ** (18 - decimals)`

**PATTERN 2: Share Price Manipulation**
- **Where:** Functions that calculate shares from assets or vice versa
- **Look For:**
  - First depositor advantages (check MIN_SHARES blocks it)
  - Donation-based inflation (check MIN_SHARES blocks it)
  - Flash loan based manipulation (check if it actually profits)
- **Functions to Check:**
  - `Vault.deposit()`
  - `Vault.mint()`
  - `convertToShares()`
  - `convertToAssets()`

**PATTERN 3: Accounting Mismatch**
- **Where:** Multiple storage variables track same logical value
- **Look For:**
  - One updates but other doesn't
  - Race conditions between updates
  - Stale reads between updates
- **Variables to Check:**
  - `totalFreeDebt` vs sum of `freeDebtShares`
  - `totalPaidDebt` vs sum of `paidDebtShares`
  - `_cachedCollateralBalances` vs actual balance
  - `freePsmAssets` vs vault balance

**PATTERN 4: State Machine Confusion**
- **Where:** Functions that change user status/state
- **Look For:**
  - Can user skip required state transitions?
  - Can user be in two states simultaneously?
  - Can state transition be front-run for profit?
- **Functions to Check:**
  - `setRedemptionStatus()`
  - `adjust()` (changing collateral AND debt)
  - Liquidation state changes

**PATTERN 5: Oracle Handling Bugs**
- **Where:** Functions that use price from oracle
- **Look For:**
  - Stale price used when fresh required
  - Zero price not handled
  - Precision loss in price calculations
  - Reduce-only mode bypass
- **Functions to Check:**
  - `getCollateralPrice()`
  - `getFeedPrice()`
  - Anywhere `price` is used in calculations

**PATTERN 6: Liquidation Logic**
- **Where:** Liquidation and writeOff functions
- **Look For:**
  - Can liquidation be blocked?
  - Can attacker force liquidation of safe position?
  - Can liquidation incentive be manipulated?
  - Can writeOff be triggered prematurely?
- **Functions to Check:**
  - `liquidate()`
  - `writeOff()`
  - `getLiquidatableDebt()`
  - `getLiquidationIncentiveBps()`

**PATTERN 7: Interest Accrual Edge Cases**
- **Where:** Interest calculation and accrual functions
- **Look For:**
  - Time manipulation (large block.timestamp values)
  - Rate manipulation (extreme free debt ratios)
  - Accrual skip conditions
  - Fee calculation errors
- **Functions to Check:**
  - `accrueInterest()`
  - `InterestModel.calculateInterest()`
  - `getPendingInterest()`

---

### 6.3 TESTING CHECKLIST FOR EACH FUNCTION

**When analyzing ANY function, ask:**

1. **Input Validation**
   - [ ] Can I pass extreme values? (0, type(uint).max, negative as int)
   - [ ] Can I pass malicious addresses? (address(0), address(this), arbitrary contract)
   - [ ] Can I bypass require statements? (front-run, reentrancy, state manipulation)

2. **State Changes**
   - [ ] What state variables change?
   - [ ] What order do they change in?
   - [ ] Can I read stale state during execution?
   - [ ] Can I reenter and exploit ordering?

3. **External Calls**
   - [ ] What external contracts are called?
   - [ ] Can I control the called contract? (If not trusted deployment)
   - [ ] Can the call fail safely?
   - [ ] Is state updated before or after the call?

4. **Math Operations**
   - [ ] Can any calculation overflow? (unlikely in 0.8.24, but check)
   - [ ] Can any division by zero occur?
   - [ ] What direction does rounding go?
   - [ ] Can I manipulate inputs to exploit rounding?

5. **Access Control**
   - [ ] Who can call this function?
   - [ ] Can I bypass access control? (delegations, operator changes)
   - [ ] Can I call on behalf of another user? (front-run their tx)
   - [ ] Can I call when I shouldn't? (after deadline, during reduce-only)

6. **Invariant Impact**
   - [ ] Does this function affect any of INV-1 through INV-9?
   - [ ] Can I make this function violate an invariant?
   - [ ] What's the state before and after?
   - [ ] Can I prove invariant break with test?

---

## üèÅ FINAL CHECKLIST BEFORE SUBMISSION

### SUBMISSION READINESS CHECKLIST

**‚úÖ MUST HAVE:**
- [ ] Code references are 100% accurate (file, line numbers, function names)
- [ ] Math is verified correct (calculated by hand or verified in test)
- [ ] Exploit path is COMPLETE (no "somehow attacker does X")
- [ ] PoC test compiles and runs
- [ ] Test demonstrates actual profit or invariant break
- [ ] NOT in any exclusion list
- [ ] NOT a misunderstanding from Section 3
- [ ] Breaks at least one invariant from Section 4.2
- [ ] Severity is justified by impact (Section 4.1)
- [ ] All red flags from Section 5.2 are addressed

**‚úÖ IDEAL TO HAVE:**
- [ ] Economic calculation shows profit > gas costs
- [ ] Multiple attack vectors shown if applicable
- [ ] Clear remediation suggestion
- [ ] Comparison to similar known vulnerabilities
- [ ] Edge cases considered

**‚ùå AUTO-INVALID IF:**
- [ ] Mentions rebasing tokens, fee-on-transfer, or ERC777 without proving CEI break
- [ ] Claims "operator can deploy malicious X"
- [ ] Claims "Chainlink could be compromised"
- [ ] Math shows attacker LOSES money
- [ ] Code references are wrong
- [ ] Finding is in PRIOR AUDIT or EXCLUDED FINDINGS lists
- [ ] Confuses Vault (Coin staking) with collateral storage
- [ ] Claims ERC4626 inflation without accounting for MIN_SHARES
- [ ] Claims "view function staleness" without state impact

---

## üìö SUMMARY: THE GOLDEN RULES

1. **READ THE CODE** - Don't pattern match, understand what actually happens
2. **VERIFY MATH** - Calculate by hand, shares can't lie
3. **CHECK EXCLUSIONS** - 5 separate lists to cross-reference
4. **WRITE POC** - If you can't code it, you don't understand it
5. **PROVE PROFIT** - Show actual value extraction, not theoretical
6. **TEST INVARIANTS** - At least one INV-1 to INV-9 must break
7. **AVOID RED FLAGS** - If it triggers Section 5.2, rethink completely
8. **BE SPECIFIC** - "Could happen" ‚â† "Will happen with these exact steps"
9. **UNDERSTAND SCOPE** - Trusted deployment, honest oracle, standard ERC20
10. **WHEN IN DOUBT, REREAD** - This guide has your answer

---

**THIS GUIDE PREVENTS:**
- ‚úì Resubmitting excluded findings
- ‚úì Invalid code references  
- ‚úì Backward math errors
- ‚úì Out-of-scope attacks
- ‚úì Misunderstanding protocol architecture
- ‚úì Missing why your attack doesn't work
- ‚úì Wasting time on invalid paths

**USE THIS FOR EVERY FINDING. NO EXCEPTIONS.** üéØ