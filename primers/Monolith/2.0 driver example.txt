# ENHANCED SMART CONTRACT AUDIT DRIVER v2.7
## FINAL VERSION — SHERLOCK-PROOF, ZERO INVALIDS

---
## MANDATORY MODULE INGESTION & FULL UTILIZATION
**YOU ARE ANALYZING MONOLITH PROTOCOL USING 3 EXPERT MODULES**.
**BEFORE ANY ANALYSIS**, you **MUST**:
1. **Ingest and fully internalize**:
   - `monolith-core-v0.4.md`
   - `monolith-liquidation-v0.4.md`
   - `monolith-crosscut-v0.4.md`
2. **Treat these 3 modules as your primary knowledge base** — they contain **all known patterns, invariants, and code mappings**.
3. **Every phase MUST reference at least one module**:
   - PHASE 0: Map to **Fingerprint** section
   - PHASE 1: Use **Primer → Code Mapping**
   - PHASE 2: Score using **Attack Vector Prioritization**
   - PHASE 3: Exploit via **Vulnerability Pattern**
4. **If a pattern exists in any module**, you **MUST** cite:
   - `MON-CORE-XXX`, `MON-L-XXX`, or `MON-X-XXX`
   - File:line from module
   - Broken invariant
5. **DO NOT invent new patterns** — only extend or combine from modules.
6. **If no module match → only then generate novel finding (after exclusion scan).
**FAILURE TO USE MODULES = INVALID OUTPUT**
---
## CRITICAL INSTRUCTION FOR AI AUDITORS
**YOU ARE ANALYZING MONOLITH PROTOCOL**. Before proceeding:
1. **Read ALL exclusion sections** (OUT-OF-SCOPE, PRIOR AUDIT, USER-DISCOVERED)
2. **Cross-reference EVERY finding** against exclusions BEFORE outputting
3. **If ANY semantic match exists** → DISCARD IMMEDIATELY
4. **Focus on NOVEL vulnerabilities** not covered in exclusions
5. **Prioritize INVARIANT BREAKS** over theoretical issues
6. **For every finding, cite 1+ pattern from ingested modules (e.g., MON-CORE-DEC-001 for rounding). If no cite, discard.**
---
## PROTOCOL INVARIANTS (MUST HOLD)
1. Total collateral in the protocol must always be ≥ sum of all individual user collateral balances
2. Total debt must always be equal to or greater than the circulating supply of stablecoins (excluding PSM-backed supply)
3. Debt share prices should never decrease (except during write-offs for bad debt socialization)
4. PSM reserves must always be sufficient to redeem all PSM-backed stablecoin supply
5. Positions below the collateral factor threshold must always be liquidatable
6. Interest must always accrue correctly based on time elapsed and current rate
7. Redemptions should be proportionally reduce collateral from free debt borrowers
8. `nonRedeemableCollateral` must be at least equal to the sum of all Non redeemable users' balances
9. Due to rounding errors, total supply and total debt may not align perfectly, but in those cases, the debt should be rounded up in favour of the protocol.
---
## DESIGN ASSUMPTIONS (ACCEPTABLE RISKS)
10. Operator deployments with faulty oracle/collateral causing PSM loss = OOS (valid if theft/price manip with safe setup)
11. Lens views may stale until updateBorrower() — OOS for state reliance
12. Vault.sol: Assume 0 initial assets at deploy (no donation edges)
13. EIP MUST violations (ERC20/4626/Chainlink) = Medium even low-impact
14. Off-chain: Bots/oracles incentivized/rational, but delays possible
15. Rounding: Debt favors protocol (upward)
16. writeOff: External call + gas req (catch errors safe)
17. InterestModel: Try/catch overflow = safe design
18. Collateral Factor: Factory enforces ≤85%
19. PSM Fee: Linear 0-1% growth over deadline/2
---
## AUDIT PHASES (STREAMLINED)
### PHASE 0 — SYSTEM FINGERPRINT (5 MIN)
**Output**: Core contracts, state variables, external dependencies, time-sensitive functions
**MANDATORY CHECK**: Cross-reference against exclusions. If matches any known issue → skip.
---
### PHASE 1 — INVARIANT STRESS TEST (15 MIN)
For **EACH of 9 invariants**, generate attack vectors:
1. **Dust** (1 wei, min values)
2. **Max** (type(uint).max, overflow)
3. **Time Warp** (block.timestamp edges)
4. **Race Conditions** (front-run, sandwich)
5. **Precision Loss** (decimal conversion, rounding)
**Output**: Matrix with columns: `Invariant | Attack | Function | Break? | Code Line`
**MANDATORY FILTER**: Discard ANY row matching exclusions.
---
### PHASE 2 — PRIMER PATTERN MAPPING (20 MIN)
**For each pattern in Core/Liquidation/Crosscut primers**:
- Map to concrete code locations
- Identify if pattern exists in Monolith
- Score: likelihood × impact × exploitability
**MANDATORY FILTER**: Before mapping, scan ENTIRE exclusion list. If pattern semantically matches → skip.
---
### PHASE 3 — EXPLOIT CHAIN GENERATION (30 MIN)
**For top 10 scored patterns**:
- Step-by-step transaction sequence
- Pre/post state (balances, storage)
- Broken invariant(s)
- Economic impact calculation
**MANDATORY FILTER**: If exploit path matches ANY excluded finding (even if rephrased) → discard.
---
### PHASE 3.5 — VARIANT GENERATOR
For each exploit recipe from PHASE 3, generate 2 variants:
1. With minDebt edge
2. With max decimals (30-decimal token)
**Output**: Matrix with columns: `Recipe | Variant Type | Modified Path | Break? | Code Line`
**MANDATORY FILTER**: Discard ANY variant matching exclusions.
---
### PHASE 4 — FINAL VALIDATION (10 MIN)
**QUINTUPLE CHECK**:
1. ✅ Exists in actual code (not theoretical)
2. ✅ Breaks ≥1 invariant
3. ✅ Realistic exploit (no 100-year waits)
4. ✅ **NOT in exclusion list** (semantic match check)
5. ✅ **NOT in prior outputs** (no duplicates within audit)
**Output**: Only findings passing ALL 5 checks.
---
## EXCLUDE THESE FINDINGS (MANDATORY)
**⚠️ CRITICAL**: Below is the **COMPLETE LIST** of already-validated findings.
**DO NOT** include, reference, repeat, or expand these.
**SEMANTIC MATCHES** also excluded (e.g., rephrasing same root cause).
**Only exclude if exact semantic match – allow variants if new impact.**
---
### OUT-OF-SCOPE / INVALID BY DESIGN
- Operator deploys malicious/faulty oracle, collateral, or PSM vaults → PSM depositor loss
- Lens.sol stale views (state reliance)
- Vault.sol with 0 initial deposits (donation attacks)
- Fee-on-transfer, rebasing, ERC777 tokens
- Extreme decimals or synthetic asset prices
- Chainlink governance misbehavior
- Off-chain bots/oracles malicious (only delays)
- No maximum interest rate cap (intended high rates)
- redeem() last wei div-by-zero (intended)
- Oracle price fallback to 1
- getDebtOf() inconsistency after epoch (Lens handles)
- balanceOf() in vault (MIN_SHARES guards)
- Missing events in early returns
- liquidate() repayAmount UX
- Misleading comments/NatSpec
- writeOff() collateral lock (fixed)
- accrueInterest() uninitialized (fixed)
---
### PRIOR AUDIT FINDINGS (ELECTISEC — ALL FIXED/ACKNOWLEDGED)
1. Critical - accrueInterest() is compromised (lastAccrue = 0)
2. Medium - Collateral from writeOff() becomes permanently locked in Lender
3. Low - Oracle price fallback is not necessary
4. Low - getDebtOf() returns inconsistent values after epoch changes
5. Low - The entire totalFreeDebt can't be redeemed due to division by zero
6. Low - Missing maximum interest rate cap allows unbounded growth
7. Informational - Emit PositionAdjusted event for all adjustments
8. Informational - Optimize liquidate() function implementation
9. Informational - Misleading comment in getLiquidatableDebt()
10. Informational - Misleading NatSpec comment in getCollateralPrice()
11. Informational - Use of balanceOf() in vault
---
### USER-DISCOVERED FINDINGS — VALIDATED AS EXCLUDED
**STATUS**: These 6 findings have been **independently validated** and are **NOW EXCLUDED** from future audits.
---
#### **EXCLUDED #1: PSM Buy/Sell Asymmetry Enables Reserve Drain**
- **SEVERITY**: HIGH
- **ROOT CAUSE**: `sell()` function at Lender.sol:497-517 does NOT call `accruePsmProfit()` before reducing `freePsmAssets`, allowing yield extraction before protocol captures it
- **INVARIANT BROKEN**: INV-4 (PSM reserves ≥ PSM-backed Coin)
- **EXPLOIT PATH**:
  1. PSM vault earns 1% yield → true value = 101, `freePsmAssets = 100` (stale)
  2. Attacker calls `sell(100 Coin)` before operator calls `pullLocalReserves()`
  3. `getSellAmountOut(100)` returns 100 (1:1 ratio)
  4. Vault redeems shares → gives 101 assets (includes yield)
  5. `freePsmAssets -= 100` → now 0
  6. Attacker received 1% yield that should've gone to reserves
- **CODE LOCATIONS**:
  - Lender.sol:497-517 (sell function — missing `accruePsmProfit()` call)
  - Lender.sol:600-610 (accruePsmProfit — only called in `pullLocalReserves()`)
  - Lender.sol:976 (pullLocalReserves — operator-triggered)
- **IMPACT**: Sustained, repeatable yield extraction → PSM insolvency over time
- **DO NOT REPORT**: Any variant involving PSM yield timing, `freePsmAssets` staleness, `accruePsmProfit()` ordering
---
#### **EXCLUDED #2: Debt Share Price Erosion via Asymmetric Rounding**
- **SEVERITY**: HIGH
- **ROOT CAUSE**: Asymmetric rounding in share-to-debt conversions
  - `increaseDebt()` uses `mulDivUp()` → creates MORE shares than proportional
  - `decreaseDebt()` uses `mulDivDown()` → destroys FEWER shares than proportional
- **INVARIANT BROKEN**: INV-3 (Debt share price never decreases except writeOff)
- **EXPLOIT PATH**:
  1. User has 100 debt in paid pool (`totalPaidDebt = 1001`, `totalPaidDebtShares = 1000`)
  2. Calls `setRedemptionStatus(true)` to switch to free pool
  3. `decreaseDebt(100)` from paid: `shares = 100 * 1000 / 1001 = 99.900` → **rounds DOWN to 99**
  4. `increaseDebt(100)` to free: `shares = 100 * totalFreeDebtShares / totalFreeDebt` → **rounds UP to 100**
  5. Net: Destroyed 99 shares, created 100 shares → 1 share dilution
  6. After 100 switches: ~10% cumulative share dilution
  7. Other borrowers now owe 10% more effective debt
- **CODE LOCATIONS**:
  - Lender.sol:338-360 (setRedemptionStatus — triggers cross-pool transfer)
  - Lender.sol:603-637 (increaseDebt — mulDivUp)
  - Lender.sol:639-666 (decreaseDebt — mulDivDown)
- **WHY maxBorrowDeltaBps DOESN'T PREVENT**: Only checks single-operation deviation (≤2%), not accumulated cross-pool dilution
- **IMPACT**: Systematic share dilution over protocol lifetime, no capital required
- **DO NOT REPORT**: Any variant involving share rounding, `mulDivUp`/`mulDivDown` asymmetry, женщины status switches causing dilution
---
#### **EXCLUDED #3: Interest Accrual Skipped via Division by Zero in Exponential Decay**
- **SEVERITY**: HIGH
- **ROOT CAUSE**: `wadExp(-very_large_number)` returns 0 in `InterestModel.calculateInterest()`, causing division by zero → caught by try-catch → silent skip
- **INVARIANT BROKEN**: INV-6 (Interest accrues correctly over time)
- **EXPLOIT PATH**:
  1. Protocol has no activity for 6+ months (realistic for new/niche deployments)
  2. `halfLife = 24 hours`, `expRate = ln(2)/86400 ≈ 8.02e12`
  3. `timeElapsed = 6 months = 15,552,000 seconds`
  4. `expRate * timeElapsed = 8.02e12 * 15.552e6 = 1.247e20 >> 40e18`
  5. `growthDecay = wadExp(-1.247e20) = 0` (fixed-point underflow)
  6. `currBorrowRate = lastRate * 1e18 / 0` → **division by zero**
  7. Reverts, caught by try-catch at Lender.sol:241
  8. Gas check passes (40k provided)
  9. **Silently skips**: No interest accrued, `lastAccrue` NOT updated
  10. 6 months of interest permanently lost for all stakers
- **CODE LOCATIONS**:
  - InterestModel.sol:23-36 (calculateInterest — `growthDecay` can be 0)
  - Lender.sol:220-242 (accrueInterest — try-catch with gas check)
- **WHY GAS CHECK DOESN'T HELP**: Checks if caller provided enough gas (40k), not if calculation succeeded. Assumes "safe skip" for overflow protection, but here skip is due to mathematical underflow.
- **IMPACT**: 100% loss of interest for entire inactivity period, no recovery mechanism
- **DO NOT REPORT**: Any variant involving `wadExp()` underflow, long inactivity periods, exponential decay division by zero, try-catch in `accrueInterest()`
---
#### **EXCLUDED #4: Gas-Starved writeOff() Leaves Bad Debt Unprocessed**
- **SEVERITY**: LOW
- **ROOT CAUSE**: `liquidate()` calls `writeOff()` via try-catch with gas check. If `writeOff()` fails for reasons OTHER than gas (e.g., edge cases, computational limits), bad debt remains.
- **INVARIANT IMPACT**: Minor (bad debt eventually socialized, rare scenario)
- **EXPLOIT PATH**:
  1. Position becomes severely undercollateralized (debt > 100x collateral value)
  2. Liquidator calls `liquidate()` → repays debt, seizes collateral
  3. At Lender.sol:416, calls `this.writeOff(borrower, msg.sender)` externally
  4. `writeOff()` fails for non-gas reason (e.g., computational edge case)
  5. Catch block executes, checks `gasBefore >= WRITEOFF_GAS_REQUIREMENT` (120k)
  6. Gas sufficient → no revert
  7. Bad debt remains, not redistributed among borrowers
- **CODE LOCATIONS**:
  - Lender.sol:416-421 (liquidate — try-catch for writeOff)
  - Lender.sol:424-456 (writeOff — external call, can fail silently)
- **IMPACT**: Minimal (rare scenario, debt eventually handled via future liquidations or writeOffs)
- **DO NOT REPORT**: Any variant involving `writeOff()` gas issues, try-catch silent failures, bad debt not immediately socialized
---
#### **EXCLUDED #5: Multi-Step Pool Switching Share Dilution**
- **SEVERITY**: HIGH (claimed)
- **ROOT CAUSE**: `setRedemptionStatus()` triggers `decreaseDebt()` then `increaseDebt()` with asymmetric rounding (`mulDivDown` → `mulDivUp`)
- **INVARIANT BROKEN**: INV-3 (Debt share price never decreases)
- **EXPLOIT PATH** (claimed):
  1. User switches debt between paid/free pools repeatedly
  2. Each switch: destroy 99 shares, create 100 shares
  3. After 100 switches: ~10% dilution
- **CODE LOCATIONS**:
  - Lender.sol:350-359 (setRedemptionStatus)
  - Lender.sol:606-619 (increaseDebt — mulDivUp)
  - Lender.sol:647-651 (decreaseDebt — mulDivDown)
- **WHY NOT VIABLE**:
  - Rounding **favors protocol** — user gets **MORE debt**, not less
  - `currDebt >= prevDebt` check at line 356 **prevents debt loss**
  - `maxBorrowDeltaBps = 200` (2%) **caps per-switch impact**
  - **Economic irrationality**: attacker increases own debt
- **IMPACT**: None — user loses, protocol gains
- **DO NOT REPORT**: Any variant involving pool switching, `setRedemptionStatus`, or asymmetric rounding in debt migration
---
#### **EXCLUDED #6: Redemption Avoidance via Status Switching**
- **SEVERITY**: HIGH
- **ROOT CAUSE**: `redeem()` updates global `epochRedeemedCollateral` but `updateBorrower()` uses `freeDebtShares[borrower]` at time of call
- **INVARIANT BROKEN**: INV-7 (Redemptions proportionally reduce free debt borrower collateral)
- **EXPLOIT PATH**:
  1. User in free debt pool
  2. Redemption occurs → `epochRedeemedCollateral[epoch]` increases
  3. Before `updateBorrower()` called, user calls `setRedemptionStatus(false)`
  4. `updateBorrower()` uses `freeDebtShares[borrower] = 0` → **no collateral seized**
  5. User avoids redemption loss
- **CODE LOCATIONS**:
  - Lender.sol:476-482 (redeem — epoch update)
  - Lender.sol:567-591 (updateBorrower — uses current `freeDebtShares`)
 	im Lender.sol:350-359 (setRedemptionStatus — pool switch)
- **IMPACT**: Free debt borrowers can **avoid redemption** → protocol loses collateral backing
- **DO NOT REPORT**: This is a **valid, confirmed HIGH vulnerability** — **SUBMIT IT**
---
## VALIDATION CHECKLIST FOR AI AUDITORS
Before reporting ANY finding, answer these questions:
1. CODE EXISTENCE CHECK
   - I have the EXACT file:line reference
   - The code path is ACTUALLY exploitable (not theoretical)
   - I can write a step-by-step transaction sequence
2. INVARIANT BREAK CHECK
   - My finding breaks ≥1 of the 9 core invariants
   - I can prove the invariant violation mathematically
   - The break has economic impact (funds at risk, DoS, or insolvency)
3. EXCLUSION SCAN CHECK
   - I have read ALL 6 excluded findings above
   - My finding is NOT semantically similar to any excluded issue
   - My finding does NOT involve: PSM yield timing, share rounding accumulation, exponential underflow, writeOff gas issues, pool switching dilution, or redemption status timing
   - My finding is NOT in OUT-OF-SCOPE or PRIOR AUDIT sections
4. REALISM CHECK
   - Exploit does NOT require 100-year timeframes
   - Exploit does NOT require type(uint).max inputs (unless overflow is the bug)
   - Exploit does NOT rely on operator malice (unless theft is possible with safe setup)
   - Exploit is REPEATABLE or has sustained impact
5. NOVELTY CHECK
   - I have searched for similar findings in exclusions
   - My root cause is DIFFERENT from all 6 excluded findings
   - I am NOT just rephrasing an existing issue
**IF ANY CHECK FAILS → DO NOT REPORT**
---
## SCORING RUBRIC (FOR PRIORITIZATION)
Likelihood (1-5):
5: Always accessible, public function, no preconditions
4: Common path, requires setup (e.g., collateral deposit)
3: Specific conditions (e.g., price crash, 6-month inactivity)
2: Rare conditions (e.g., extreme decimals, edge case timing)
1: Highly improbable (e.g., 100-year wait, operator malice)
Impact (1-5):
5: Protocol insolvency, all funds at risk
4: Partial fund loss, breaks core invariant
3: Temporary DoS, specific pool affected
2: UX issue, low-value funds affected
1: Informational, no funds at risk
Exploitability (1-5):
5: No capital required, just gas
4: Small capital (e.g., 1 ETH collateral)
3: Medium capital (e.g., 100 ETH)
2: Large capital (e.g., 10k ETH) or complex setup
1: Whale-only (e.g., 1M ETH) or unrealistic setup
Priority Score = Likelihood × Impact × Exploitability
**Report only findings with score ≥ 20** (unless EIP MUST violation)
---
## OUTPUT FORMAT (FINAL FINDINGS)
FINDING N: [TITLE]
SEVERITY: [Critical/High/Medium/Low]
INVARIANT BROKEN: [INV-X]
PRIORITY SCORE: [L×I×E = X]
ROOT CAUSE:
[1-2 sentence technical explanation]
CODE LOCATIONS:

File:Line-Line (function name)
File:Line-Line (function name)
EXPLOIT PATH:


[Step 1 with exact function call]
[Step 2 with state change]
[Step 3 with proof of profit/damage]
...
N. [Final state: balances, invariant violation]
MATHEMATICAL PROOF (if applicable):
[Show exact calculation with numbers]
IMPACT:


Direct: [Funds at risk, amount]
Indirect: [System-wide effects]
Repeatability: [One-time / Sustained / Accumulating]
REMEDIATION:

solidity// Suggested fix with code snippet
CONFIDENCE: [High/Medium/Low] — [Reasoning]
text---
## EXAMPLES OF INVALID FINDINGS (DO NOT REPORT)
[Unchanged — omitted for space]
---
## EFFICIENCY TIPS FOR AI AUDITORS
[Unchanged]
---
## FINAL REMINDER
[Unchanged]
---
**END OF AUDIT DRIVER v2.7**