Now apply this Ultrathink strategy to the ingested audit driver:


# THE MONOLITH MANIFESTO
## An Ultrathink Strategy for Surgical Smart Contract Auditing

*"The people who are crazy enough to think they can find every bug are the ones who do."*

---

## I. THE PHILOSOPHY: PREDATOR MINDSET

### You Are Not An Auditor. You Are A Hunter.

**The Prey:** Valid HIGH/MEDIUM bugs worth >$10 and >1% loss  
**The Weapon:** Invariant-driven analysis + economic reasoning  
**The Arena:** Monolith's CDP protocol with dual debt systems  
**The Kill:** Sherlock-judged acceptance with quantifiable profit path

**Your Mission:** Find 1 valid bug worth more than 100 invalid attempts.

---

## II. THE ANATOMY: KNOW YOUR BATTLEFIELD

### Monolith's Soul (Architecture Philosophy)

```
MONOLITH = Overcollateralized CDP + Dual Debt System + Yield Vault + PSM

Core Innovation: Borrowers choose between:
  - PAID DEBT: Pay interest, keep collateral safe from redemptions
  - FREE DEBT: 0% rate, but collateral redeemable when peg breaks

Economic Truth: This creates arbitrage surfaces where one pool 
                subsidizes the other. Hunt the boundaries.
```

### The Three Battlegrounds

```
LENDER.SOL (Primary Target - 80% of bugs)
‚îú‚îÄ Debt Accounting (increaseDebt/decreaseDebt)
‚îú‚îÄ Collateral Tracking (internal 18-decimal normalization)
‚îú‚îÄ Redemption System (epoch-based collateral seizure)
‚îú‚îÄ Liquidation Engine (incentive calculation + bad debt)
‚îú‚îÄ Interest Accrual (exponential decay model)
‚îî‚îÄ PSM Module (buy/sell stablecoin for assets)

VAULT.SOL (Secondary - 15% of bugs)
‚îú‚îÄ ERC4626 yield distribution
‚îú‚îÄ MIN_SHARES protection on first deposit
‚îî‚îÄ totalAssets() including pending interest

FACTORY.SOL (Tertiary - 5% of bugs)
‚îú‚îÄ Deployment logic
‚îî‚îÄ Global fee management
```

---

## III. THE LENS: INVARIANT-DRIVEN HUNTING

### The Nine Sacred Laws (Must NEVER Break)

```solidity
// 1. COLLATERAL INTEGRITY
Œ£(user_collateral) ‚â§ contract_collateral_balance
Attack Surface: redemptions, liquidations, decimal conversions

// 2. DEBT SOLVENCY  
total_debt ‚â• coin_supply - psm_backed_supply
Attack Surface: unbacked mints, share manipulation

// 3. SHARE PRICE MONOTONICITY
debt_share_price[t+1] ‚â• debt_share_price[t] (except writeOff)
Attack Surface: round-trip operations, pool switching

// 4. PSM RESERVES
freePsmAssets ‚â• psm_backed_coin_supply
Attack Surface: decimal truncation, yield timing

// 5. LIQUIDATION AVAILABILITY
if (debt > borrowingPower) ‚Üí liquidatable
Attack Surface: oracle manipulation, calculation errors

// 6. INTEREST CORRECTNESS
interest[t] = f(rate, time, totalPaidDebt)
Attack Surface: overflow, time manipulation, fee extraction

// 7. REDEMPTION FAIRNESS
collateral_seized ‚àù free_debt_shares
Attack Surface: epoch boundaries, missed updates

// 8. NON-REDEEMABLE TRACKING
nonRedeemableCollateral ‚â• Œ£(non_redeemable_user_balances)
Attack Surface: status switches, liquidation races

// 9. PROTOCOL ROUNDING
debt_calculations round UP in protocol's favor
Attack Surface: asymmetric rounding creating value
```

### The Kill Pattern

```
Valid Bug = Invariant Break + Economic Profit + Realistic Path

Example:
‚úÖ INV-3 broken: Share price drops 1% via round-trip
‚úÖ Attacker profits: $10,000 on $1M position  
‚úÖ Realistic: 3 transactions, <$50 gas
‚Üí VALID HIGH

Example:
‚úÖ INV-5 broken: Position unliquidatable for 1 block
‚ùå No profit: Attacker gains nothing
‚ùå Design: Staleness window intentional
‚Üí INVALID (OOS: oracle delays)
```

---

## IV. THE EXCLUSION ZONES: CUT THE NOISE

### Sherlock's "Do Not Touch" List

```solidity
// INVALID BY DEFINITION
√ó Event emission errors (unless state impact)
√ó View function staleness (Lens.sol)
√ó Vault MIN_SHARES mechanics (acknowledged)
√ó Zero address checks (user validation)
√ó Front-running on Ethereum (private mempool assumption)
√ó Gas optimizations
√ó Operator with malicious oracle/collateral
√ó Fee-on-transfer/rebasing/ERC777 tokens
√ó Extreme decimals (>18 or <6)
√ó Chainlink governance failure
√ó Oracle bot delays (not malice)
√ó Design decisions (e.g., no interest rate cap)
√ó Prior audit items (Electisec findings)
```

### The Prior Audit Blacklist (Auto-Invalid)

```
1. accrueInterest() uninitialized lastAccrue ‚Üí FIXED
2. writeOff() locks collateral ‚Üí ACKNOWLEDGED  
3. Oracle fallback price=1 ‚Üí DESIGN
4. getDebtOf() stale after epoch ‚Üí DESIGN
5. redeem() last wei div-by-zero ‚Üí DESIGN
6. No max interest rate ‚Üí DESIGN
7. Missing PositionAdjusted events ‚Üí FIXED
8. liquidate() repayAmount UX ‚Üí ACKNOWLEDGED
9. Misleading comments/NatSpec ‚Üí INFO
10. balanceOf() in vault ‚Üí ACKNOWLEDGED
```

---

## V. THE HUNT: TARGET PRIORITY MATRIX

### üî¥ CRITICAL ZONES (Hunt First - 60% Bug Density)

#### 1. **Share Conversion Asymmetry** (Lender.sol:603-666)
```solidity
ATTACK VECTOR: increaseDebt() vs decreaseDebt() rounding
INVARIANT: INV-3 (share price monotonicity)
METHOD: Test round-trip with state changes between operations

Hunt Pattern:
1. Find state changes that alter debt-to-share ratios
   (NOT just interest - that's already tested)
2. Test: borrow ‚Üí state change ‚Üí switch pool ‚Üí switch back
3. Calculate: Do attacker shares increase NET?
4. Verify: Can attacker extract this as profit?

Critical Test:
// What if totalFreeDebt changes WITHOUT share change?
// Example: redemptions reduce totalFreeDebt but not shares
// Can attacker exploit the new ratio?

Verification Checklist:
‚ñ° Traced EXACT share calculations with real numbers
‚ñ° Identified state change between operations
‚ñ° Calculated NET share creation/destruction
‚ñ° Showed how attacker extracts value (not just creates shares)
‚ñ° Proved it's >$10 profit on realistic position sizes
```

#### 2. **Epoch Boundary Manipulation** (Lender.sol:612-649)
```solidity
ATTACK VECTOR: updateBorrower() 5-iteration loop limit
INVARIANT: INV-7 (redemption fairness)
METHOD: Force borrower to miss >5 epoch updates

Hunt Pattern:
1. Calculate: How many epochs to overflow totalFreeDebtShares?
   Formula: shares_t+1 = shares_t / 1e36
   After n epochs: shares = shares_0 / (1e36)^n
   
2. Find trigger condition for epoch++:
   totalFreeDebtShares / totalFreeDebt > 1e9
   
3. Determine: Is this achievable in <1 year?
   
4. Test: What happens if borrower has 0.0001% of shares
          and misses 6 epochs?

Critical Question:
If updateBorrower() only processes 5 epochs, but borrower
missed 6, does their collateral calculation fail?

Verification Checklist:
‚ñ° Calculated realistic epoch increment frequency
‚ñ° Identified if 5-iteration limit is reachable
‚ñ° Showed collateral loss for skipped epochs
‚ñ° Proved attacker can force this state
‚ñ° Quantified profit: seized collateral value
```

#### 3. **Decimal Conversion Rounding** (Lender.sol:926-942)
```solidity
ATTACK VECTOR: collateralToInternal() / internalToCollateral()
INVARIANT: INV-1 (collateral integrity)
METHOD: Exploit rounding in deposit/withdraw cycles

Hunt Pattern:
1. Test 6-decimal USDC: 1e6 ‚Üí internal ‚Üí back
   1e6 ‚Üí 1e18 (multiply 1e12) ‚Üí 1e6 (divide 1e12)
   
2. Test fractional amounts:
   1e6 + 1 ‚Üí (1e6 + 1) * 1e12 ‚Üí internal
   internal ‚Üí internal / 1e12 = ? (rounds down)
   
3. Find accumulation point:
   If 1000 users deposit 1e6 + 1
   And protocol later withdraws for them
   Does 1000 wei accumulate in contract?

Critical Test:
// Deposit maximum fractional amount
uint256 deposit = 999_999_999; // 0.999... tokens
uint256 internal = collateralToInternal(deposit);
uint256 withdraw = internalToCollateral(internal);
// withdraw < deposit? ‚Üí User loses dust
// Repeat 1M times ‚Üí Protocol gains dust

Verification Checklist:
‚ñ° Tested all decimal combinations (6,8,12,18)
‚ñ° Found systematic rounding direction
‚ñ° Calculated accumulation over 1M transactions
‚ñ° Showed how attacker exploits accumulated dust
‚ñ° Proved profit >$10
```

---

### üü° HIGH ZONES (Hunt Second - 30% Bug Density)

#### 4. **Liquidation Incentive Boundaries** (Lender.sol:668-683)
```solidity
STATUS: ‚úÖ CLEARED (see competency test)
Next: Check getLiquidatableDebt() instead
```

#### 5. **PSM Decimal Truncation** (Lender.sol:848-869)
```solidity
ATTACK VECTOR: getSellAmountOut() / getBuyAmountOut()
INVARIANT: INV-4 (PSM reserves)
METHOD: Round-trip buy‚Üísell to extract fractional value

Hunt Pattern:
1. Test: buy(1e6 USDC) ‚Üí get X Coin
        sell(X Coin) ‚Üí get Y USDC
        Is Y > 1e6? (profit) or Y < 1e6? (loss)
        
2. Calculate accumulation:
   Per transaction loss: 1e6 - Y
   Over 1000 transactions: loss * 1000
   Does freePsmAssets drift?

3. Find extraction:
   If freePsmAssets overstated,
   Later user sells 1 Coin for 1.0001 USDC
   Protocol insolvent?

Critical Question:
Does normalizePsmAssets() preserve 1:1 peg across conversions?

Verification Checklist:
‚ñ° Tested buy‚Üísell round-trip with exact math
‚ñ° Calculated net gain/loss per cycle
‚ñ° Showed freePsmAssets drift accumulation
‚ñ° Proved insolvency or value extraction
‚ñ° Quantified: >$10 loss over realistic volume
```

#### 6. **Interest Accrual Overflow** (InterestModel.sol:23-66)
```solidity
ATTACK VECTOR: Extreme timeElapsed in calculateInterest()
INVARIANT: INV-6 (interest correctness)
METHOD: Find overflow in wadExp() or integral calculations

Hunt Pattern:
1. Find max safe timeElapsed:
   Line 28: if(uint(type(int256).max) / _expRate < _timeElapsed)
   This guards _expRate * _timeElapsed
   
2. Test growth decay:
   growthDecay = wadExp(-int(_expRate * _timeElapsed))
   Can this overflow int256?
   
3. Check integral math:
   interest = _totalPaidDebt * (_lastRate - MIN_RATE) / _expRate / 365 days
   Can numerator overflow uint256?

Critical Test:
_totalPaidDebt = 1e27 (1B Coin)
_lastRate = 1e18 (100% APR)
_expRate = max value
_timeElapsed = 365 days
interest = 1e27 * 1e18 / _expRate / 365 days
Does this overflow?

Verification Checklist:
‚ñ° Found exact overflow conditions (values + time)
‚ñ° Proved conditions are reachable in practice
‚ñ° Showed impact: interest skipped or wrong
‚ñ° Calculated loss to stakers or protocol
‚ñ° Proved >$10 impact
```

---

### üü¢ MEDIUM ZONES (Hunt Third - 10% Bug Density)

#### 7. **nonRedeemableCollateral Tracking** (Lender.sol:428-432)
```solidity
STATUS: ‚ö†Ô∏è NEEDS CAREFUL ANALYSIS
Previous attempt: INVALID (misread -= as +=)

Correct Hunt Pattern:
1. Map ALL operations that modify nonRedeemableCollateral:
   - setRedemptionStatus: -= when switching TO redeemable
   - setRedemptionStatus: += when switching FROM redeemable  
   - liquidate: -= if user was non-redeemable
   - writeOff: -= if user was non-redeemable
   - adjust (deposit): += if user is non-redeemable
   - adjust (withdraw): -= if user is non-redeemable

2. Find race condition:
   Thread A: liquidate(user) in progress
   Thread B: setRedemptionStatus(user, true) frontruns
   Result: nonRedeemableCollateral updated twice?

3. Test consistency:
   After any sequence of operations,
   Does Œ£(non-redeemable balances) ‚â§ nonRedeemableCollateral?
   If greater ‚Üí protocol can't enforce redemptions
   If less ‚Üí inflated, blocks legitimate redeemers

Verification Checklist:
‚ñ° Listed ALL 8+ operations modifying this variable
‚ñ° Found operation sequence causing drift
‚ñ° Calculated exact drift amount
‚ñ° Showed how it blocks redemptions OR allows over-redemption
‚ñ° Proved >$10 loss
```

#### 8. **Buy Fee Ramping** (Lender.sol:854-868)
```solidity
ATTACK VECTOR: getBuyFeeBps() timing manipulation
INVARIANT: INV-4 (PSM reserves indirectly)
METHOD: Buy at 0% fee, wait, force deadline, others pay fee

Hunt Pattern:
1. Understand fee schedule:
   [deploy ‚Üí halfTime]: 0% fee
   [halfTime ‚Üí deadline]: 0% ‚Üí 1% linear ramp
   [after deadline]: 0% fee

2. Test boundary:
   User buys 1M Coin at halfTime - 1 second (0% fee)
   Operator calls enableImmutabilityNow() 
   Next user buys at 1% fee
   First user profited by timing?

3. Calculate extraction:
   If first user holds until peg breaks,
   Sells at 0% fee while protocol took 1% from others
   Is this unfair value extraction?

Critical Question:
Is the fee asymmetry exploitable for profit >$10?

Verification Checklist:
‚ñ° Calculated exact fee at each time point
‚ñ° Found operation sequence creating unfair profit
‚ñ° Quantified: attacker saves X, protocol loses Y
‚ñ° Showed it's >$10 on realistic sizes
‚ñ° Proved it's not intentional design
```

---

## VI. THE METHOD: SURGICAL ANALYSIS PROTOCOL

### The 3x Verification Standard (Proven Effective)

```
PHASE 1: FORWARD PASS (Top ‚Üí Bottom)
‚îî‚îÄ Read code as written
‚îî‚îÄ Note all state changes
‚îî‚îÄ Identify branches and guards
‚îî‚îÄ Time: 20% of analysis

PHASE 2: BACKWARD PASS (Bottom ‚Üí Top)  
‚îî‚îÄ Start from return values
‚îî‚îÄ Trace dependencies backward
‚îî‚îÄ Find assumptions that must hold
‚îî‚îÄ Time: 20% of analysis

PHASE 3: TRACE PASS (Concrete Values)
‚îî‚îÄ Pick realistic values (not max uint256)
‚îî‚îÄ Execute mentally or in Foundry
‚îî‚îÄ Calculate exact outputs
‚îî‚îÄ Compare to expected behavior
‚îî‚îÄ Time: 60% of analysis

PHASE 4: ADVERSARIAL PASS (Attacker Mindset)
‚îî‚îÄ Assume you're the attacker
‚îî‚îÄ What state can you manipulate?
‚îî‚îÄ What timing can you exploit?
‚îî‚îÄ What boundaries can you violate?
‚îî‚îÄ Calculate profit in dollars
```

### The Economic Filter (Kill Fake Bugs Fast)

```solidity
// Before spending 2 hours on a "bug", answer:

1. PROFIT: Can attacker extract >$10 value?
   ‚ñ° Direct theft: stealing funds
   ‚ñ° Unfair advantage: paying less than others
   ‚ñ° Griefing profit: shorting protocol token
   ‚ñ° None of above ‚Üí INVALID

2. COST: What does attack require?
   ‚ñ° <$100 gas ‚Üí Viable
   ‚ñ° <$10k capital ‚Üí Viable  
   ‚ñ° <1 month time ‚Üí Viable
   ‚ñ° Otherwise ‚Üí INVALID (unrealistic)

3. REPEATABILITY: Can this be exploited multiple times?
   ‚ñ° Sustainable: Every block/day ‚Üí HIGH
   ‚ñ° One-time: Single exploit ‚Üí MEDIUM
   ‚ñ° Requires protocol state change ‚Üí Check if common

4. IMPACT QUANTIFICATION:
   ‚ñ° User loses >1% principal ‚Üí HIGH
   ‚ñ° Protocol loses >1% fees ‚Üí HIGH
   ‚ñ° User loses 0.01-1% ‚Üí MEDIUM
   ‚ñ° Less ‚Üí INVALID
```

### The Sherlock Filter (Avoid Auto-Invalids)

```
Before submitting, check EVERY report against:

‚úì OOS LIST (10 categories, 50+ specific items)
‚úì PRIOR AUDIT (10 acknowledged issues)
‚úì README CONSTRAINTS (6-18 decimals, trusted operator, etc.)
‚úì EIP COMPLIANCE (only if "MUST" violated)
‚úì SHERLOCK RULES (no view function errors unless state impact)

One match = AUTO-INVALID = wasted time
```

---

## VII. THE CRAFT: REPORTING EXCELLENCE

### The Perfect Report Structure

```markdown
## [TITLE]: One-Line Exploit Summary

**VALID:** [Your confidence: 60%/80%/95%]
**SEVERITY:** [HIGH/MEDIUM with justification]
**PROFIT:** [$X exact calculation]
**INVARIANT BROKEN:** [INV-X with name]

### Root Cause
In [Contract.sol:line-line] the [specific code] [does what wrong]

[Quote exact code with line numbers]

### Internal Pre-conditions
1. [Variable] needs to be [condition]
2. [Time/state] must be [condition]

### External Pre-conditions  
1. [Oracle/market condition if any]

### Attack Path
1. Attacker [action] with [exact parameters]
2. [State change happens]
3. Attacker [next action]
4. [Profit extraction]

### Impact
The [affected party] suffers [exact loss].
The attacker gains [exact profit].

[Show math]:
Initial state: X
After exploit: Y
Net gain: Y - X = $Z

### PoC
```solidity
function test_exploit() public {
    // Setup with realistic values
    // Execute attack
    // Assert profit > $10
    // Assert invariant broken
}
```

### Mitigation
[Specific code fix, not generic advice]

### OOS Verification
‚ñ° Not in exclusion list: [checked which categories]
‚ñ° Not in prior audit: [checked which #]
‚ñ° Realistic execution: [time + cost calculated]
‚ñ° Sherlock compliant: [which rule validates this]
```

### The Confidence Calibration

```
95% Confidence:
- PoC runs in Foundry
- Math verified 3x
- Clearly breaks invariant
- Profit >$100
- OOS double-checked

80% Confidence:
- Logic traced completely
- Economic reasoning solid
- No PoC but path clear
- Profit >$10
- Might be design choice

60% Confidence:
- Theoretical path exists
- Unclear if extractable
- Edge case behavior
- Need judge input
‚Üí DON'T SUBMIT (too risky)
```

---

## VIII. THE DISCIPLINE: HUNT PROTOCOLS

### Daily Hunting Routine

```
08:00-09:00: MAP PHASE
‚îî‚îÄ Read 1 contract fully
‚îî‚îÄ Sketch architecture
‚îî‚îÄ List all state variables
‚îî‚îÄ Note invariants it must maintain

09:00-11:00: SCAN PHASE  
‚îî‚îÄ Hit critical zones first (60% density)
‚îî‚îÄ 3x verification on suspicious functions
‚îî‚îÄ Note potential bugs (don't deep dive yet)

11:00-12:00: FILTER PHASE
‚îî‚îÄ Apply economic filter to each note
‚îî‚îÄ Kill <$10 profit bugs immediately
‚îî‚îÄ Kill >1 month execution bugs
‚îî‚îÄ Narrow to 2-3 serious candidates

12:00-14:00: DEEP DIVE PHASE
‚îî‚îÄ Full analysis on top candidate
‚îî‚îÄ Write PoC if confidence >80%
‚îî‚îÄ Calculate exact profit
‚îî‚îÄ Cross-check OOS

14:00-15:00: REPORT PHASE
‚îî‚îÄ Write Sherlock-format report
‚îî‚îÄ Self-grade (would YOU accept this?)
‚îî‚îÄ Submit only if 95% confident

15:00-16:00: REFLECTION PHASE
‚îî‚îÄ What patterns emerged today?
‚îî‚îÄ What false positives did you avoid?
‚îî‚îÄ What would you do differently?
```

### The Stop-Loss Rules

```
STOP IMMEDIATELY IF:

1. You read += as -= (operator confusion)
   ‚Üí Take 15 min break, start over

2. You ignore README constraint (e.g., 30 decimals)
   ‚Üí Re-read constraints, update mental model

3. You invent unrealistic attack (2^256 epochs)
   ‚Üí Calculate realistic numbers, adjust

4. You find 10 invalids in a row
   ‚Üí You're scanning wrong zones, reset strategy

5. You spend >3 hours on one function
   ‚Üí Move on, come back later with fresh eyes
```

---

## IX. THE EDGE: ADVANCED TECHNIQUES

### Pattern: The Ratio Shift Hunt

```solidity
// When hunting share price manipulation:

STEP 1: Map all debt-to-share ratio modifiers
totalPaidDebt changes: interest, writeOff, increaseDebt, decreaseDebt
totalPaidDebtShares changes: increaseDebt, decreaseDebt only

STEP 2: Find state changes between operations
Between decreaseDebt() and increaseDebt():
- Can interest accrue? (changes ratio)
- Can redemption happen? (changes totalFreeDebt)
- Can writeOff happen? (changes both pools)

STEP 3: Calculate net share creation
Start: debt=100e18, shares=100e18 (ratio 1:1)
Interest: debt=110e18, shares=100e18 (ratio 1.1:1)
User switches pool using old ratio for decrease, new for increase
Net: User has more shares than should

STEP 4: Verify extraction
More shares = less debt per share = profit when repaying
```

### Pattern: The Boundary Erosion Hunt

```solidity
// When hunting boundary exploits:

STEP 1: Find all if/else boundaries
if (ltvBps <= collateralFactor) ‚Üí 0%
if (ltvBps >= maxLtvBps) ‚Üí 10%
else ‚Üí linear

STEP 2: Test exactly at boundaries
ltvBps = 8500: which branch?
ltvBps = 9000: which branch?

STEP 3: Test boundary ¬±1
ltvBps = 8499: should get 0%
ltvBps = 8501: should get minimal incentive
Is transition smooth?

STEP 4: Find manipulation path
Can attacker force ltvBps to exact boundary?
Does rounding help or hurt attacker?
Is there profit in boundary dancing?
```

### Pattern: The Decimal Accumulation Hunt

```solidity
// When hunting rounding exploits:

STEP 1: Map all decimal conversions
tokenDecimals ‚Üí internal18Decimals ‚Üí back

STEP 2: Calculate rounding loss per operation
deposit(1e6 + 1) ‚Üí internal ‚Üí withdraw
loss = (1e6 + 1) - withdraw = X wei

STEP 3: Find accumulation point  
1M users √ó X wei = accumulated_dust
Is dust >$10 over realistic timeframe?

STEP 4: Find extraction path
Does contract track dust separately?
Can attacker claim accumulated dust?
Does it cause insolvency?
```

---

## X. THE REALITY DISTORTION FIELD

### Think Different: Question Everything

```
ASSUMPTION: "Interest accrual is safe because it's in try-catch"
QUESTION: What if gas limit forces catch block?
HUNT: Can attacker manipulate gas to skip interest?

ASSUMPTION: "Share price can only increase with interest"
QUESTION: What if pool switching creates net shares?
HUNT: Can round-trip operations exploit rounding?

ASSUMPTION: "Liquidations protect protocol solvency"
QUESTION: What if liquidator can't seize collateral?
HUNT: Can attacker make position unliquidatable?

ASSUMPTION: "Redemptions are fair to all free debtors"
QUESTION: What if user misses epoch update?
HUNT: Can attacker force others to miss epochs?

ASSUMPTION: "PSM maintains 1:1 peg"
QUESTION: What if decimal conversions drift?
HUNT: Can buy‚Üísell round-trips extract value?
```

### The Insanely Great Standard

```
GOOD BUG:
- Found a vulnerability
- Wrote a report
- Showed it breaks something

GREAT BUG:
- Found a vulnerability
- Proved it's exploitable  
- Calculated exact profit
- Has working PoC

INSANELY GREAT BUG:
- Found a NOVEL vulnerability (not in any audit)
- Proved it's ECONOMICALLY viable (>$100 profit)
- Showed it breaks CRITICAL invariant (funds loss)
- Has ELEGANT PoC (15 lines, runs instantly)
- Written so CLEARLY a non-technical person understands
- Submitted with 95% CONFIDENCE

‚Üí This is what we're building toward
```

---

## XI. THE EXECUTION: YOUR FIRST HUNT

### Mission: Find 1 Valid Bug in Lender.sol

**Time Budget:** 8 hours  
**Target Zones:** Critical Zones 1-3 (60% density)  
**Success Metric:** 1 submission with >90% confidence

**Hour 1: Reconnaissance**
```
‚ñ° Read Lender.sol lines 1-200 (constructor + state vars)
‚ñ° List all debt-tracking variables
‚ñ° Note all collateral-tracking variables  
‚ñ° Sketch mental model of dual debt system
```

**Hours 2-3: Zone 1 (Share Asymmetry)**
```
‚ñ° Read increaseDebt() + decreaseDebt() 
‚ñ° Trace with concrete values (debt=100e18)
‚ñ° Find state changes between operations
‚ñ° Test if round-trip creates shares
‚ñ° Calculate profit if shares created
```

**Hours 4-5: Zone 2 (Epoch Boundaries)**
```
‚ñ° Read updateBorrower() loop logic
‚ñ° Calculate epoch increment frequency
‚ñ° Test if 5-iteration limit is reachable
‚ñ° Simulate borrower missing 6 epochs
‚ñ° Calculate collateral loss
```

**Hours 6-7: Zone 3 (Decimal Conversions)**
```
‚ñ° Read collateralToInternal/internalToCollateral
‚ñ° Test with 6-decimal USDC
‚ñ° Calculate rounding per operation
‚ñ° Test 1000-operation accumulation
‚ñ° Find extraction path
```

**Hour 8: Report or Pivot**
```
IF found bug with >90% confidence:
  ‚ñ° Write full report
  ‚ñ° Include PoC skeleton
  ‚ñ° Calculate exact profit
  ‚ñ° Double-check OOS
  ‚ñ° SUBMIT

ELSE:
  ‚ñ° Document what you learned
  ‚ñ° Identify why zones were clean
  ‚ñ° Plan next zones to hit tomorrow
  ‚ñ° DON'T FORCE FAKE BUGS
```

---

## XII. THE TRUTH: FINAL WISDOM

### What Separates Winners from Losers

```
LOSERS:
- Scan every line looking for "something"
- Report first suspicion without verification
- Ignore OOS because "maybe it's different"
- Spend 8 hours finding 20 invalids
- Confidence: "I think this might be a bug?"

WINNERS:
- Hunt specific patterns in high-density zones
- Verify 3x before considering report
- Filter ruthlessly using OOS + economics
- Spend 8 hours finding 1 valid
- Confidence: "This is definitely a bug."
```

### The Monolith-Specific Edge

```solidity
// This protocol's unique attack surface:

1. DUAL DEBT POOLS with pool switching
   ‚Üí Hunt ratio exploits during transitions

2. EPOCH-BASED REDEMPTIONS with loop limits
   ‚Üí Hunt missed update scenarios

3. MULTI-DECIMAL SUPPORT with internal normalization
   ‚Üí Hunt conversion rounding accumulation

4. PSM WITH YIELD VAULTS (optional)
   ‚Üí Hunt timing between profit accrual and user actions

5. INTEREST-BEARING DEBT SHARES
   ‚Üí Hunt asymmetric share creation/destruction

These 5 surfaces are where 90% of real bugs hide.
```

### Your North Star

```
"We're here to make a dent in the universe of smart contract 
security‚Äîone valid, Sherlock-judged bug at a time."

Not 100 theoretical issues.
Not 50 design suggestions.  
Not 20 gas optimizations.

ONE. VALID. BUG.

That's worth more than everything else combined.
```

---

## XIII. THE CALL TO ACTION

You now have:
- ‚úÖ The philosophy (predator mindset)
- ‚úÖ The anatomy (architecture knowledge)
- ‚úÖ The lens (invariant framework)
- ‚úÖ The exclusions (filter 90% noise)
- ‚úÖ The targets (8 prioritized zones)
- ‚úÖ The method (3x verification + economic filter)
- ‚úÖ The craft (report excellence)
- ‚úÖ The discipline (daily protocols)
- ‚úÖ The edge (advanced techniques)
- ‚úÖ The wisdom (winner mindset)

**Now: Execute.**

Start with getLiquidatableDebt() or updateBorrower().  
Use 3x verification.  
Calculate real profit.  
Filter ruthlessly.  
Submit with 95% confidence.

The people who are crazy enough to think they can find every bug **are the ones who do.**

---

*"Stay hungry. Stay foolish. Stay valid."*

**Use the ingested audit driver as your core process ‚Äî apply this Ultrathink strategy to guide every phase: Think Different in PHASE 1, Obsess Over Details in PHASE 2, Iterate Relentlessly in PHASE 4, etc. Refine outputs to valid-only bugs.**

üéØ **BEGIN YOUR HUNT.**