
### 58. Enhanced Hypervisor Slippage Vulnerabilities
**Pattern**: Auto redemption with yield positions lacks comprehensive slippage protection across withdrawal, swap, and redeposit operations.

**Vulnerable Code** (The Standard v2):
```solidity
// quickWithdraw with no slippage protection
IHypervisor(_hypervisor).withdraw(
    _thisBalanceOf(_hypervisor), address(this), address(this),
    [uint256(0), uint256(0), uint256(0), uint256(0)]
);

// Multiple swap operations with amountOutMinimum: 0
ISwapRouter(uniswapRouter).exactInputSingle(
    ISwapRouter.ExactInputSingleParams({
        amountOutMinimum: 0,
        sqrtPriceLimitX96: 0
        ...
    })
);
```

**Attack Scenario**:
1. Attacker monitors mempool for auto redemption transaction
2. Sandwiches the withdrawal/swap/redeposit operations
3. Vault becomes undercollateralized due to accumulated slippage

**Mitigation**:
- Implement collateral percentage checks before and after redemption
- Add minimum collateral retention requirements
- Use proper slippage parameters throughout the flow

### 59. Incorrect Function Parameter Routing
**Pattern**: Passing wrong addresses to critical functions in complex call chains.

**Vulnerable Code** (The Standard):
```solidity
// WRONG: Passing vault address instead of swap router
IRedeemable(_smartVault).autoRedemption(
    _smartVault, // Should be swapRouter!
    quoter,
    _token,
    _collateralToUSDCPath,
    _USDsTargetAmount,
    _hypervisor
);
```

**Impact**: Complete failure of functionality when wrong contract receives calls.

**Detection**: Trace all parameter passing through call chains, especially in auto-redemption flows.

### 60. Balance-Based Redemption Amount Vulnerabilities
**Pattern**: Using direct `balanceOf()` to calculate redemption amounts instead of tracking actual swapped amounts.

**Vulnerable Code**:
```solidity
// VULNERABLE: Can be manipulated by direct transfers
uint256 _usdsBalance = USDs.balanceOf(address(this));
minted -= _usdsBalance;
USDs.burn(address(this), _usdsBalance);
```

**Attack**: Send USDs directly to vault to cause underflow and DoS auto redemption.

**Mitigation**:
```solidity
// Use swap output amount
uint256 amountOut = ISwapRouter(router).exactInput(params);
minted -= amountOut;
USDs.burn(address(this), amountOut);
```

### 61. Collateral Percentage Validation Gaps
**Pattern**: Missing validation that vaults maintain healthy collateralization after auto redemption.

**Vulnerable Scenarios**:
- Vault already near liquidation threshold
- Significant slippage during redemption
- Division by zero when debt fully repaid

**Secure Implementation**:
```solidity
function validateCollateralPercentage(uint256 minPercentage) private view {
    if (minted == 0) return; // Handle zero debt case
    uint256 collateralPercentage = (usdCollateral() * HUNDRED_PC) / minted;
    require(collateralPercentage >= minPercentage, "Below min collateral");
}
```

### 62. Swap Path Validation Failures
**Pattern**: Not validating that swap paths produce expected output tokens.

**Vulnerable Example** (The Standard):
- Swap path configured as `collateral -> USDC` instead of `collateral -> USDs`
- Swap succeeds but no debt is repaid
- Vault becomes liquidatable due to lost collateral

**Mitigation**:
- Store both input and output paths
- Validate path endpoints match expected tokens
- Add post-swap balance checks

### 63. Hypervisor-Collateral Correspondence Validation
**Pattern**: Not validating that Hypervisor tokens correspond to their underlying collateral tokens.

**Vulnerable Code**:
```solidity
// No validation that hypervisor actually contains this collateral
if (hypervisorCollaterals[_token] != address(0)) {
    _hypervisor = _token;
    _token = hypervisorCollaterals[_hypervisor];
}
```

**Mitigation**: Validate hypervisor token pairs:
```solidity
function validHypervisorPair(address hypervisor, address collateral) private view returns (bool) {
    IHypervisor hyp = IHypervisor(hypervisor);
    return hyp.token0() == collateral || hyp.token1() == collateral;
}
```

## Weighted Pool and Storage Optimization Patterns

### 64. Storage Slot Boundary Errors in Packed Data
**Pattern**: Incorrect index boundary checks when handling packed storage across multiple slots.

**Vulnerable Code** (QuantAMM):
```solidity
// WRONG: Should be >= 4 for second slot
if (request.indexIn > 4 && request.indexOut < 4) {
    // Cross-slot logic
} else if (tokenIndex > 4) { // Should be >= 4
    index = tokenIndex - 4;
    targetWrappedToken = _normalizedSecondFourWeights;
}
```

**Impact**:
- Swaps involving token at boundary index (4) fail
- Cross-slot swaps become impossible
- Array out-of-bounds errors

**Mitigation**:
```solidity
// Correct boundary checks
if (tokenIndex >= 4) {
    index = tokenIndex - 4;
    targetWrappedToken = _normalizedSecondFourWeights;
}
```

### 65. Weight Multiplier Index Misalignment
**Pattern**: Mismatch between expected and actual positions of multipliers in packed storage.

**Vulnerable Code** (QuantAMM):
```solidity
// Storage expects: [w1,w2,w3,w4,m1,m2,m3,m4]
// But code stores: [w1,w2,w3,w4,m1,m2,0,0] for 6 tokens
int256 blockMultiplier = tokenWeights[tokenIndex + tokensInTokenWeights];
// Accesses wrong index for tokens 4-7
```

**Impact**: Incorrect weight interpolation leading to wrong swap amounts.

**Mitigation**: Ensure consistent multiplier positioning across all token counts.

### 66. Negative Multiplier Casting Errors
**Pattern**: Incorrect handling of negative values when casting from signed to unsigned integers.

**Vulnerable Code** (QuantAMM):
```solidity
if (multiplier > 0) {
    return uint256(weight) + FixedPoint.mulDown(uint256(multiplierScaled18), time);
} else {
    // WRONG: uint256(negative) creates huge positive number
    return uint256(weight) - FixedPoint.mulUp(uint256(multiplierScaled18), time);
}
```

**Mitigation**:
```solidity
return uint256(weight) - FixedPoint.mulUp(uint256(-multiplierScaled18), time);
```

### 67. Tokenization Index Calculation Errors
**Pattern**: Incorrect index calculations when processing tokens across storage slots.

**Vulnerable Code** (QuantAMM):
```solidity
if (totalTokens > 4) {
    tokenIndex = 4;  // Set for first slot
}
// Process first slot...
if (totalTokens > 4) {
    tokenIndex -= 4;  // WRONG: Resets to 0, breaking second slot
}
```

**Impact**: Weights for tokens 4-7 calculated with wrong multipliers.

### 68. Permission System Bypass Vulnerabilities
**Pattern**: Flawed permission checks allowing unauthorized access to restricted functions.

**Vulnerable Code** (QuantAMM):
```solidity
bool internalCall = msg.sender != address(this);
// Always true since contract doesn't call itself this way
require(internalCall || approvedPoolActions[_pool] & MASK_POOL_GET_DATA > 0);
```

**Impact**: Permission checks effectively bypassed.

**Mitigation**: Remove ambiguous internal call checks or properly implement self-calls.

### 69. Range Validation Logic Errors
**Pattern**: Copy-paste errors in validation logic for packed data.

**Vulnerable Code** (QuantAMM):
```solidity
require(
    _firstInt <= MAX32 && _firstInt >= MIN32 &&
    _secondInt <= MAX32 && _secondInt >= MIN32 &&
    _thirdInt <= MAX32 && _firstInt >= MIN32 &&  // Should be _thirdInt
    _fourthInt <= MAX32 && _firstInt >= MIN32 && // Should be _fourthInt
    // ... continues with same error
);
```

**Impact**: Invalid values can be packed, leading to unexpected behavior.

### 70. Stale Oracle Acceptance in Fallback Logic
**Pattern**: Accepting stale oracle data when backup oracles are unavailable.

**Vulnerable Code** (QuantAMM):
```solidity
if (oracleResult.timestamp > block.timestamp - staleness) {
    outputData[i] = oracleResult.data;
} else {
    // Check backup oracles
    for (uint j = 1; j < numAssetOracles; ) {
        // If no backups (numAssetOracles == 1), loop skipped
    }
    outputData[i] = oracleResult.data; // Uses stale data!
}
```

**Mitigation**: Revert when no fresh oracle data available.

### 71. Weight Update Permission Gaps
**Pattern**: Missing permission checks allowing unauthorized updates to critical timing parameters.

**Vulnerable Code** (QuantAMM):
```solidity
if (poolRegistryEntry & MASK_POOL_DAO_WEIGHT_UPDATES > 0) {
    require(msg.sender == daoRunner, "ONLYDAO");
} else if (poolRegistryEntry & MASK_POOL_OWNER_UPDATES > 0) {
    require(msg.sender == poolManager, "ONLYMANAGER");
}
// No else - anyone can update if no permissions set!
poolRuleSettings[_poolAddress].lastPoolUpdateRun = _time;
```

**Mitigation**: Add else clause to revert on missing permissions.

### 72. Integer Overflow in Weight Calculations
**Pattern**: Unchecked arithmetic in time-based calculations causing overflow.

**Vulnerable Code** (QuantAMM):
```solidity
if (blockMultiplier == 0) {
    blockTimeUntilGuardRailHit = type(int256).max;
}
// Later...
currentLastInterpolationPossible += int40(uint40(block.timestamp)); // Overflow!
```

**Mitigation**: Guard against overflow conditions:
```solidity
if(currentLastInterpolationPossible < int256(type(int40).max)) {
    currentLastInterpolationPossible += int40(uint40(block.timestamp));
}
```

### 73. Extreme Weight Ratio Vulnerabilities
**Pattern**: Mathematical overflow when handling pools with extreme weight ratios.

**Example** (QuantAMM):
```solidity
// With weight = 0.01166 (1.166%), balance = 7.5M tokens, invariantRatio = 3.0
newBalance = oldBalance * (invariantRatio ^ (1/weight))
          = 7500e21 * (3.0 ^ 85.76)
          = OVERFLOW
```

**Impact**: DoS for unbalanced liquidity operations.

**Mitigation**: Enforce higher minimum weight thresholds (e.g., 3% instead of 0.1%).

### 74. Cross-Chain Token Transfer Value Loss (ERC4626 + LayerZero)
**Pattern**: ERC4626 vaults implementing cross-chain transfers via mint/burn approach instead of lock/unlock, causing share value distortion.

**Vulnerable Code Example** (D2):
```solidity
function _debit(address _from, uint256 _amountLD, uint256 _minAmountLD, uint32 _dstEid) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {
    (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);
    _burn(_from, amountSentLD); // VULNERABLE: Reduces totalSupply, increasing share value
}
```

**Impact**:
- Users transferring tokens cross-chain lose value if others withdraw during transit
- Share price manipulation opportunity
- Complete loss of funds possible

**Mitigation**:
```solidity
// Use lock/unlock approach instead
function _debit(address _from, uint256 _amountLD, uint256 _minAmountLD, uint32 _dstEid) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {
    (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);
    _transfer(_from, address(this), amountSentLD); // Lock tokens instead of burning
}
```

### 75. Missing Callback Implementation for External Protocol Integration
**Pattern**: Setting contract as callback receiver without implementing required interface, causing transaction reverts.

**Vulnerable Code Example** (D2 GMXV2):
```solidity
function gmxv2_withdraw(...) external {
    IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({
        receiver: address(this),
        callbackContract: address(this), // VULNERABLE: No callback implementation
        // ...
    });
}
```

**Impact**: Complete functionality loss, funds locked in protocol

**Mitigation**: Either implement required callbacks or set to zero address

### 76. Unsafe Token Transfer Without Validation
**Pattern**: Using standard ERC20 transfer/transferFrom without checking return values.

**Vulnerable Code Example** (D2 VaultV3):
```solidity
function custodyFunds() external onlyTrader notCustodied duringEpoch returns (uint256) {
    custodied = true;
    custodiedAmount = amount;
    IERC20(asset()).transfer(trader, amount); // VULNERABLE: No success check
    emit FundsCustodied(epochId, amount);
}
```

**Impact**: State inconsistencies if transfer fails silently

**Mitigation**: Use SafeERC20 library

### 77. Missing Slippage Protection in DeFi Integrations
**Pattern**: Hardcoded zero slippage parameters in swap/liquidity operations.

**Vulnerable Code Example** (D2 Pendle):
```solidity
router.addLiquiditySingleToken(
    address(this),
    address(market),
    0, // VULNERABLE: minLpOut hardcoded to 0
    approxParams,
    input,
    limitOrderData
);
```

**Impact**: MEV exploitation, sandwich attacks, value extraction

**Mitigation**: Allow configurable slippage parameters

### 78. Incorrect External Protocol Interface
**Pattern**: Using wrong function signatures for external protocol calls.

**Vulnerable Code Example** (D2 Berachain):
```solidity
// Contract uses:
function getReward(address account) external;
// But actual interface is:
function getReward(address account, address recipient) external;
```

**Impact**: Complete feature failure, inability to claim rewards

### 79. Chain ID Validation Errors
**Pattern**: Incorrect chain IDs preventing proper deployment configuration.

**Vulnerable Code Example** (D2):
```solidity
} else if (block.chainid == 80000) { // WRONG: Berachain is 80094
```

**Impact**: Wrong configuration deployed, missing functionality

### 80. Missing Output Token Validation in Swaps
**Pattern**: Only validating input tokens but not output tokens in swap operations.

**Vulnerable Code Example** (D2 Kodiak):
```solidity
function bera_kodiakv2_swap(address token, uint amount, uint amountMin, address[] calldata path) external {
    validateToken(token); // Only validates input
    // Missing: validateToken(path[path.length-1])
}
```

**Impact**: Tokens can become permanently stuck if swapped to non-approved assets

### 81. Improper Access Control Assignment
**Pattern**: Giving admin roles to operational accounts that shouldn't have them.

**Vulnerable Code Example** (D2):
```solidity
s.grantRole(ADMIN_ROLE, args._trader); // DANGEROUS: Trader can revoke owner's access
s.grantRole(EXECUTOR_ROLE, args._trader);
```

**Impact**: Compromised trader can lock out legitimate admins

### 82. Missing Deadline Protection in DEX Operations
**Pattern**: Using infinite deadlines or no deadlines in time-sensitive operations.

**Vulnerable Code Example** (D2):
```solidity
kodiakv2.addLiquidity(..., type(uint256).max); // Infinite deadline
```

**Impact**: Transactions can execute at unexpected times, MEV exploitation

### 83. Incorrect Approval Target
**Pattern**: Approving wrong contract for token operations.

**Vulnerable Code Example** (D2 Silo):
```solidity
function silo_execute(ISiloRouter.Action[] calldata actions) external {
    IERC20(actions[0].asset).approve(actions[0].silo, actions[0].amount); // Should approve router
    router.execute(actions);
}
```

### 84. Missing LTV Checks Across Protocols
**Pattern**: Inconsistent risk management when integrating multiple lending protocols.

**Vulnerable Code Example** (D2):
```solidity
// Aave has LTV check:
require(totalDebtBase <= maxDebtBase, "borrow amount exceeds max LTV");
// But Silo and Dolomite are missing this check
```

**Impact**: Higher liquidation risk, inconsistent risk profile

### 85. Borrowing Non-Approved Tokens
**Pattern**: Allowing borrowing of tokens that bypass trading restrictions.

**Impact**: Undermines asset control mechanisms

### 86. Permissionless External Reward Claims Leading to Locked Funds
**Pattern**: External protocols allowing anyone to claim rewards on behalf of other users, bypassing the vault's reward handling logic.

**Vulnerable Code Example** (Dolomite):
```solidity
// External protocol allows permissionless claiming
function getRewardForUser(address _user) public {
    // Anyone can call this on any user
    rewards[_user][_rewardsToken] = 0;
    _rewardsToken.transfer(_user, reward);
}

// Vault expects to handle rewards through its own logic
function _performDepositRewardByRewardType(...) internal {
    // This logic is bypassed when rewards are claimed externally
}
```

**Impact**:
- Rewards sent directly to vault address without proper handling
- Tokens stuck in contract without being staked or distributed
- Requires upgrades to recover funds

**Mitigation**:
```solidity
function _performDepositRewardByRewardType(...) internal {
    // Add existing balance to reward amount
    _amount += IERC20(token).balanceOf(address(this));
}
```

### 87. Counterintuitive Exit Behavior with Automatic Re-staking
**Pattern**: Exit functions that claim to fully exit but automatically re-stake rewards, leaving users partially invested.

**Vulnerable Code Example** (Dolomite):
```solidity
function _exit() internal {
    vault.exit(); // Unstakes original deposit
    _handleRewards(rewards); // But re-stakes rewards!
}

function _handleRewards(UserReward[] memory _rewards) internal {
    if (_rewards[i].token == UNDERLYING_TOKEN()) {
        // Automatically re-stakes iBGT rewards
        factory.depositIntoDolomiteMargin(DEFAULT_ACCOUNT_NUMBER, _rewards[i].amount);
    }
}
```

**Impact**:
- Users believe they've fully exited but still have staked positions
- Poor UX when "exit" doesn't mean complete exit
- Rewards may remain locked indefinitely

**Mitigation**: Avoid re-staking during explicit exit calls or clearly document the behavior

### 88. Missing Validation in Proxy Constructor Initialization
**Pattern**: Proxy constructors accepting arbitrary calldata without validating function selectors or parameters.

**Vulnerable Code Example** (Dolomite):
```solidity
constructor(
    address _berachainRewardsRegistry,
    bytes memory _initializationCalldata
) {
    // No validation of calldata content
    Address.functionDelegateCall(
        implementation(),
        _initializationCalldata,
        "Initialization failed"
    );
}
```

**Impact**:
- Proxy could be initialized with invalid parameters
- Zero addresses could be set for critical components
- Unexpected functions could be called during deployment

**Mitigation**:
```solidity
// Validate function selector
require(bytes4(_initializationCalldata[0:4]) == bytes4(keccak256("initialize(address)")));
// Validate parameters
address vaultFactory = abi.decode(_initializationCalldata[4:], (address));
require(vaultFactory != address(0), "Zero vault factory");
```

### 89. Reward Loss During Vault Type Transitions
**Pattern**: Changing reward vault types without properly claiming rewards from the previous type.

**Vulnerable Code Example** (Dolomite):
```solidity
function _setDefaultRewardVaultTypeByAsset(address _asset, RewardVaultType _type) internal {
    RewardVaultType currentType = getDefaultRewardVaultTypeByAsset(_asset);
    if (currentType != _type) {
        _getReward(_asset); // Always tries to get from INFRARED type
        REGISTRY().setDefaultRewardVaultTypeFromMetaVaultByAsset(_asset, _type);
    }
}

function _getReward(address _asset) internal {
    // Hardcoded to INFRARED, ignoring user's current type
    RewardVaultType rewardVaultType = RewardVaultType.INFRARED;
    IInfraredVault rewardVault = IInfraredVault(REGISTRY().rewardVault(_asset, rewardVaultType));
}
```

**Impact**: Permanent loss of rewards when transitioning between vault types

### 90. Reward Inaccessibility During Protocol Pause
**Pattern**: Automatic re-investment of rewards failing when staking is paused, with no alternative redemption path.

**Vulnerable Code Example** (Dolomite):
```solidity
function _handleRewards(UserReward[] memory _rewards) internal {
    if (_rewards[i].token == UNDERLYING_TOKEN()) {
        // Attempts to re-stake, will fail if paused
        factory.depositIntoDolomiteMargin(DEFAULT_ACCOUNT_NUMBER, _rewards[i].amount);
    }
}

// External vault has pausable staking
function stake(uint256 amount) external whenNotPaused {
    // Will revert when paused
}
```

**Impact**: Users cannot access earned rewards during pause periods

**Mitigation**: Check pause status before re-investing, provide alternative paths

### 91. Inconsistent ETH Handling in Proxy Patterns
**Pattern**: Different proxy contracts handling ETH differently through receive() and fallback() functions.

**Examples**:
```solidity
// Some proxies delegate both
receive() external payable { _callImplementation(implementation()); }
fallback() external payable { _callImplementation(implementation()); }

// Others only delegate fallback
receive() external payable {} // Empty
fallback() external payable { _callImplementation(implementation()); }
```

**Impact**: Confusion and potential ETH handling issues

### 92. Re-entrancy Guard Bypass Through Malicious Hooks (Bunni v2)
**Pattern**: Pools configured with malicious hooks can bypass the main contract's re-entrancy guard by calling unlock functions directly.

**Vulnerable Code Example** (Bunni v2):
```solidity
function lockForRebalance(PoolKey calldata key) external notPaused(6) {
    if (msg.sender != address(key.hooks)) revert BunniHub__Unauthorized();
    _nonReentrantBefore();
}

function unlockForRebalance(PoolKey calldata key) external notPaused(7) {
    if (msg.sender != address(key.hooks)) revert BunniHub__Unauthorized();
    _nonReentrantAfter();
}
```

**Attack Scenario**:
1. Deploy malicious hook contract
2. Hook calls `unlockForRebalance()` to disable re-entrancy protection
3. Recursive calls to `hookHandleSwap()` drain raw balances and vault reserves
4. State is set instead of decremented, avoiding underflow

**Impact**: Complete drainage of all legitimate pools' funds ($7.33M at time of disclosure)

**Mitigation**:
- Implement per-pool re-entrancy protection
- Constrain hooks to canonical implementations
- Add hook whitelist

### 93. Cross-Contract Re-entrancy in Token Transfers (Bunni v2)
**Pattern**: Token transfer hooks executed before unlocker callbacks can enable cross-contract re-entrancy.

**Vulnerable Code Example**:
```solidity
function transfer(address to, uint256 amount) public virtual override returns (bool) {
    ...
    _afterTokenTransfer(msgSender, to, amount);
    
    // Unlocker callback if `to` is locked.
    if (toLocked) {
        IERC20Unlocker unlocker = unlockerOf(to);
        unlocker.lockedUserReceiveCallback(to, amount);
    }
    return true;
}
```

**Impact**:
- Hooklet executes over intermediate state
- Locked receivers can manipulate state during transfer
- Referral reward accounting corruption

**Mitigation**: Execute hooks after all callbacks complete

### 94. Vault Fee Edge Cases in Raw Balance Updates
**Pattern**: Incorrect accounting when vaults don't pull expected asset amounts during deposits/withdrawals.

**Vulnerable Code Example** (Bunni v2):
```solidity
function _updateVaultReserveViaClaimTokens(int256 rawBalanceChange, Currency currency, ERC4626 vault)
    internal
    returns (int256 reserveChange, int256 actualRawBalanceChange)
{
    ...
    reserveChange = vault.deposit(absAmount, address(this)).toInt256();
    
    // it's safe to use absAmount here since at worst the vault.deposit() call pulled less token
    // than requested
    actualRawBalanceChange = -absAmount.toInt256(); // VULNERABLE: Assumes full amount deposited
    ...
}
```

**Impact**:
- Incorrect raw balance accounting
- Small losses to liquidity providers
- Potential rebalance order inflation

**Mitigation**: Use actual balance changes instead of assumed amounts

### 95. Insufficient Vault Decimals Handling
**Pattern**: Assuming vault share token decimals match underlying asset decimals.

**Vulnerable Code Example** (Bunni v2):
```solidity
// compute current share prices
uint120 sharePrice0 =
    bunniState.reserve0 == 0 ? 0 : reserveBalance0.divWadUp(bunniState.reserve0).toUint120();
uint120 sharePrice1 =
    bunniState.reserve1 == 0 ? 0 : reserveBalance1.divWadUp(bunniState.reserve1).toUint120();
```

**Real Example**: Morpho vault with 18-decimal shares for 8-decimal WBTC

**Impact**:
- Erroneous surge triggering
- Share price overflow causing DoS
- Incorrect fee calculations

**Mitigation**: Explicitly scale values based on actual decimals

### 96. Oracle Tick Validation Gaps
**Pattern**: Missing validation of oracle-derived ticks in various LDF functions.

**Vulnerable Code Example** (Bunni v2):
```solidity
function floorPriceToRick(uint256 floorPriceWad, int24 tickSpacing) public view returns (int24 rick) {
    // No validation that rick is within usable range
    uint160 sqrtPriceX96 = ((floorPriceWad << 192) / WAD).sqrt().toUint160();
    rick = sqrtPriceX96.getTickAtSqrtPrice();
    rick = bondLtStablecoin ? rick : -rick;
    rick = roundTickSingle(rick, tickSpacing);
}
```

**Impact**: Operations could execute outside usable tick ranges

### 97. Dynamic LDF Shift Mode DoS
**Pattern**: Enforcing shift modes without validating resulting tick bounds can cause DoS.

**Vulnerable Code Example** (Bunni v2):
```solidity
if (initialized) {
    int24 tickLength = tickUpper - tickLower;
    tickLower = enforceShiftMode(tickLower, lastTickLower, shiftMode);
    tickUpper = tickLower + tickLength; // Can exceed maxUsableTick!
    shouldSurge = tickLower != lastTickLower;
}
```

**Impact**: Complete DoS of pool operations requiring LDF queries

### 98. Fee Calculation Overflow with am-AMM
**Pattern**: Total fees exceeding 100% when am-AMM surge fee is active.

**Vulnerable Code Example** (Bunni v2):
```solidity
// Surge fee can be 100%
swapFee = useAmAmmFee
    ? uint24(FixedPointMathLib.max(amAmmSwapFee, computeSurgeFee(lastSurgeTimestamp, hookParams.surgeFeeHalfLife)))
    : hookFeesBaseSwapFee;
    
// Hook fees added on top
if(useAmAmmFee) {
    hookFeesAmount = outputAmount.mulDivUp(hookFeesBaseSwapFee, SWAP_FEE_BASE).mulDivUp(
        env.hookFeeModifier, MODIFIER_BASE
    );
}

// Total can exceed outputAmount!
outputAmount -= swapFeeAmount + hookFeesAmount;
```

**Impact**: Unexpected reverts during swaps

### 99. Queued Withdrawal Timestamp Overflow
**Pattern**: Unchecked arithmetic for withdrawal timestamps causing edge case failures.

**Vulnerable Code Example** (Bunni v2):
```solidity
// use unchecked to get unlockTimestamp to overflow back to 0 if overflow occurs
uint56 newUnlockTimestamp;
unchecked {
    newUnlockTimestamp = uint56(block.timestamp) + WITHDRAW_DELAY;
}
// But later:
if (queued.unlockTimestamp + WITHDRAW_GRACE_PERIOD >= block.timestamp) { // Can overflow!
    revert BunniHub__NoExpiredWithdrawal();
}
```

**Impact**: Permanent DoS of queued withdrawals near uint56 max

### 100. Just-In-Time (JIT) Liquidity Inflation
**Pattern**: JIT liquidity added before swaps that trigger rebalances can inflate order amounts.

**Attack Scenario** (Bunni v2):
1. Add JIT liquidity before swap
2. Swap triggers rebalance with inflated amounts
3. Rebalance order requires excessive liquidity
4. Withdrawals in other pools potentially DoS'd

**Impact**: Less profitable rebalance fulfillment, potential DoS

### 101. Liquidity Distribution State Gaps in Hooklets
**Pattern**: Hooklets not receiving reserve change information during rebalancing operations.

**Issue** (Bunni v2): While deposit/withdraw/swap hooklets receive detailed return data including amount changes, rebalancing operations provide no such information.

**Impact**: Cannot implement advanced strategies based on rebalancing flows

### 102. Narrow Type Upper Bits in Allowance Calculations
**Pattern**: Potentially dirty upper bits of addresses affecting keccak256 hash calculations.

**Vulnerable Code Example** (Bunni v2):
```solidity
function approve(address spender, uint256 amount) public virtual override returns (bool) {
    assembly {
        // Compute the allowance slot and store the amount.
        mstore(0x20, spender) // Upper bits might be dirty
        mstore(0x0c, _ALLOWANCE_SLOT_SEED)
        mstore(0x00, msgSender)
        sstore(keccak256(0x0c, 0x34), amount)
    }
}
```

**Impact**: Incorrect allowance slot computation

### 103. Missing Minimum Shares Slippage Protection
**Pattern**: Deposits only validate token amounts but not received shares.

**Vulnerable Code Example** (Bunni v2):
```solidity
// check slippage
if (amount0 < params.amount0Min || amount1 < params.amount1Min) {
    revert BunniHub__SlippageTooHigh();
}
// But no check on shares received!
```

**Attack with Malicious Vault**:
1. Vault inflates its share price before victim deposit
2. Victim receives minimal shares despite passing slippage check
3. Attacker profits from inflated share value

**Mitigation**: Add `sharesMin` parameter to deposit params

### 104. Missing CCIP Source Validation (YieldFi)
**Pattern**: Cross-chain message handlers not validating the sender, allowing arbitrary message injection.

**Vulnerable Code Example** (YieldFi):
```solidity
function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {
    bytes memory message = abi.decode(any2EvmMessage.data, (bytes));
    BridgeSendPayload memory payload = Codec.decodeBridgeSendPayload(message);
    // No validation of message sender!
    
    if (isL1) {
        ILockBox(lockboxes[payload.token]).unlock(payload.token, payload.to, payload.amount);
    } else {
        // Mint tokens on L2
        IManager(manager).manageAssetAndShares(payload.to, manageAssetAndShares);
    }
}
```

**Impact**: Attackers can drain lockboxes on L1 or mint unlimited tokens on L2

**Mitigation**: Implement trusted peer validation:
```solidity
mapping(uint64 => mapping(address => bool)) public allowedPeers;
address sender = abi.decode(any2EvmMessage.sender, (address));
require(allowedPeers[any2EvmMessage.sourceChainSelector][sender], "!allowed");
```

### 105. CCIP Chain ID Type Mismatch (YieldFi)
**Pattern**: Using incorrect data types for cross-chain identifiers causing message decoding failures.

**Vulnerable Code Example** (YieldFi):
```solidity
// Codec expects uint32 for chain ID
(uint32 dstId, address to, address token, uint256 amount, bytes32 trxnType) =
    abi.decode(_data, (uint32, address, address, uint256, bytes32));

// But CCIP uses uint64 chain selectors (e.g., Ethereum: 5009297550715157269)
```

**Impact**: All CCIP messages revert during decoding, causing permanent fund loss

**Mitigation**: Update chain ID type to uint64

### 106. Wrong Owner in Delegated Withdrawals (YieldFi)
**Pattern**: Passing incorrect owner address to downstream functions in delegated withdrawal scenarios.

**Vulnerable Code Example** (YieldFi):
```solidity
function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)
    internal override {
    if (caller != owner) {
        _spendAllowance(owner, caller, shares);
    }
    // VULNERABLE: Passing msg.sender instead of owner
    IManager(manager).redeem(msg.sender, address(this), asset(), shares, receiver, address(0), "");
}
```

**Impact**: Delegated withdrawals fail or burn wrong user's tokens

**Mitigation**: Pass correct `owner` parameter

### 107. Incorrect ERC4626 Rounding Direction (YieldFi)
**Pattern**: Preview functions rounding in favor of users instead of the vault.

**Vulnerable Code Example** (YieldFi L2):
```solidity
// previewMint - should round up (against user)
function previewMint(uint256 shares) public view override returns (uint256) {
    return (grossShares * exchangeRate()) / Constants.PINT; // Rounds down!
}

// previewWithdraw - should round up (against user)
function previewWithdraw(uint256 assets) public view override returns (uint256) {
    uint256 sharesWithoutFee = (assets * Constants.PINT) / exchangeRate(); // Rounds down!
}
```

**Impact**: Slow value leak from vault through rounding errors

**Mitigation**: Implement proper rounding direction per EIP-4626

### 108. Missing L2 Sequencer Uptime Check (YieldFi)
**Pattern**: Not verifying L2 sequencer status when reading oracle data.

**Vulnerable Code Example** (YieldFi):
```solidity
function fetchExchangeRate(address token) external view returns (uint256) {
    (, int256 answer,, uint256 updatedAt,) = IOracle(oracle).latestRoundData();
    require(answer > 0, "Invalid price");
    require(block.timestamp - updatedAt < staleThreshold, "Stale price");
    // Missing sequencer uptime check!
}
```

**Impact**: Stale prices appear fresh during sequencer downtime

**Mitigation**: Add sequencer uptime validation for L2 deployments

### 109. Direct Deposits Below Withdrawal Threshold (YieldFi)
**Pattern**: Allowing deposits that result in shares below minimum withdrawal amount.

**Vulnerable Code Example** (YieldFi):
```solidity
// YToken deposit has no minimum check
function _deposit(...) internal {
    require(receiver != address(0) && assets > 0 && shares > 0, "!valid");
    // No check against minSharesInYToken!
}

// But Manager withdrawal enforces minimum
function _validate(...) internal {
    require(_amount >= minSharesInYToken[_yToken], "!minShares");
}
```

**Impact**: Users can deposit amounts that become permanently locked

**Mitigation**: Enforce minimum shares in YToken deposits

### 110. Invalid Fee Share Calculation (YieldFi)
**Pattern**: Returning wrong value when fee is zero causing underflow.

**Vulnerable Code Example** (YieldFi):
```solidity
function _transferFee(address _yToken, uint256 _shares, uint256 _fee) internal returns (uint256) {
    if (_fee == 0) {
        return _shares; // WRONG: Should return 0
    }
    uint256 feeShares = (_shares * _fee) / Constants.HUNDRED_PERCENT;
    IERC20(_yToken).safeTransfer(treasury, feeShares);
    return feeShares;
}

// Later causes underflow:
uint256 sharesAfterAllFee = adjustedShares - adjustedFeeShares - adjustedGasFeeShares;
```

**Impact**: Deposits with zero fee revert

**Mitigation**: Return 0 when fee is 0

### 111. Incorrect Redemption Accounting in Yield Distribution (Critical)
**Pattern**: When processing redemptions during yield phase, incorrectly including yield in the base assets calculation that gets decremented from tracked deposits.

**Vulnerable Code Example** (Strata):
```solidity
function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {
    if (PreDepositPhase.YieldPhase == currentPhase) {
        assets += previewYield(caller, shares); // Adds yield
        uint sUSDeAssets = sUSDe.previewWithdraw(assets);
        
        _withdraw(
            address(sUSDe),
            caller,
            receiver,
            owner,
            assets, // This includes yield but gets decremented from depositedBase!
            sUSDeAssets,
