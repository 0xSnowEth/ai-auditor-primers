fit).
Test: Liquidation uses consistent price; no oracle calls mid-execution.
Multiple Collateral Diverging Prices: User: 100 aETH+100 aUSDC\text{100 aETH} + \text{100 aUSDC}
100 aETH+100 aUSDC. ETH crashes 50%, health drops proportionally\text{ETH crashes 50\%, health drops proportionally}
ETH crashes 50%, health drops proportionally. Liquidation prioritizes highest-LTV asset first.
Test: Liquidation seizes correct collateral; edge case where only partial collateral touched (bad debt remains).

10.6 DEX/AMM Exploit Patterns
Constant Product Violation via Micro-Swaps:

Execute 1000 swaps of 1 wei each
Cumulative rounding errors accumulate
Final x×y<kx \times y < k
x×y<k (product decreased)

Arbitrageur extracts difference

Test: Product must increase or stay constant; rounding always favors pool.
MEV Sandwich Attack:

Front-run: Attacker swaps before user, moves price up
User swap: Executes at worse price (higher slippage)
Back-run: Attacker swaps back, captures price difference

Test: Liquidations use TWAP, not spot price; slippage protection enforced.
LP Token Flash Loan Manipulation:

Flash borrow reserves from lending protocol
Add liquidity to pool (inflates LP token price)
Use LP tokens as collateral, borrow max
Remove liquidity, repay flash loan
Borrowed amount exceeds collateral value

Test: LP token pricing includes fee-on-withdraw; resistant to single-block manipulation.
10.7 Bridge/Cross-Chain Exploit Patterns
Message Replay Attack:

User locks 100 tokens on chain 1 (nonce=5)
Bridge mints 100 tokens on chain 2
Attacker captures signed message with nonce=5
Attacker replays message → mints another 100 tokens
Total supply on chain 2: 200 (locked on chain 1: 100)

Test: Nonce monotonicity; reject nonce≤last_processed\text{nonce} \le \text{last\_processed}
nonce≤last_processed.

Lock-Mint Atomicity Failure:

User locks 100 tokens on chain 1
Bridge message sent to chain 2
Chain 2 mint transaction fails (out of gas / revert)
User tokens locked on chain 1, nothing minted on chain 2
No refund mechanism

Test: Timeout-based refund; locked_until_timestamp expires → user withdraws on source.
Validator Consensus Bypass:

Required signatures: 3 of 5 validators
Attacker compromises 2 validators
Attacker forges message with 2 signatures
Message accepted (should require 3)

Test: Consensus threshold enforced; required_signatures=⌈2/3×active_validators⌉\text{required\_signatures} = \lceil 2/3 \times \text{active\_validators} \rceil
required_signatures=⌈2/3×active_validators⌉.

10.8 Staking/Validator Exploit Patterns
Delegation Double-Spend:

User has 100 tokens staked
User delegates 100 tokens to validator A
User delegates same 100 tokens to validator B
Total delegated: 200 (balance: 100)

Test: ∑(delegated)≤balance\sum(\text{delegated}) \le \text{balance}
∑(delegated)≤balance; only one active delegation per user.

Slashing Reversal:

Validator slashed for 10 ETH penalty
Validator attempts to re-stake immediately
Slashed amount restored via fresh deposit

Test: Slashed amount permanently subtracted; forced exit queue.
Equivocation Non-Detection:

Validator signs two conflicting blocks at height 100
Both signatures submitted to chain
No slashing triggered

Test: Duplicate signatures at same height → immediate slashing.

11. Cross-Collateral & Borrow Desync Tests
11.1 Isolated Asset Debt Ceiling Bypass

Attack: User deposits wBTC (isolated), debt ceiling=$10M\text{User deposits wBTC (isolated), debt ceiling} = \$10\text{M}
User deposits wBTC (isolated), debt ceiling=$10M. Borrow 9.9M stablecoins\text{Borrow 9.9M stablecoins}
Borrow 9.9M stablecoins. Precision loss in debt calculation via micro-repays\text{Precision loss in debt calculation via micro-repays}
Precision loss in debt calculation via micro-repays. Accumulated rounding down→borrow again→exceed ceiling\text{Accumulated rounding down} \to \text{borrow again} \to \text{exceed ceiling}
Accumulated rounding down→borrow again→exceed ceiling.

Test: totalIsolationDebt≤debtCeiling\text{totalIsolationDebt} \le \text{debtCeiling}
totalIsolationDebt≤debtCeiling for any borrow/repay/liquidation\text{borrow/repay/liquidation}
borrow/repay/liquidation sequence.


11.2 Supply Cap & Borrow Cap Desync

Supply Cap: Cap: 10M DAI, current: 9.99M, new deposit: 100K→must fail\text{Cap: 10M DAI, current: 9.99M, new deposit: 100K} \to \text{must fail}
Cap: 10M DAI, current: 9.99M, new deposit: 100K→must fail.

Borrow Cap: Cap: 5M DAI, current: 4.99M, new borrow: 200K flash loan\text{Cap: 5M DAI, current: 4.99M, new borrow: 200K flash loan}
Cap: 5M DAI, current: 4.99M, new borrow: 200K flash loan. Flash loan should bypass borrow cap OR verify cap applies to flash loans\text{Flash loan should bypass borrow cap OR verify cap applies to flash loans}
Flash loan should bypass borrow cap OR verify cap applies to flash loans.

Test: Atomic flash-loan-backed borrow behavior. Simultaneous deposits (race conditions without snapshot).

11.3 Collateral Asset Removal Edge Case

Scenario: Protocol delists asset mid-position. User has debt in active market, collateral in delisted market\text{User has debt in active market, collateral in delisted market}
User has debt in active market, collateral in delisted market. Health factor uses stale price OR zeros collateral\text{Health factor uses stale price OR zeros collateral}
Health factor uses stale price OR zeros collateral.

Test: Cannot open new borrows against delisted collateral. Existing positions must liquidate or migrate.

11.4 Multiple Debt Instruments Desync

Setup: Debt1=100@5%\text{Debt1} = 100 @ 5\%
Debt1=100@5% (accrued 110 after 2 years\text{accrued 110 after 2 years}
accrued 110 after 2 years). Debt2=100@10%\text{Debt2} = 100 @ 10\%
Debt2=100@10% (accrued 120 after 2 years\text{accrued 120 after 2 years}
accrued 120 after 2 years).

Test: Debt1 & Debt2\text{Debt1} \text{ \& } \text{Debt2}
Debt1 & Debt2 accrue independently. repay(Debt1, 50)\text{repay(Debt1, 50)}
repay(Debt1, 50) does
NOT affect Debt2\text{Debt2}
Debt2. Liquidation of Debt1\text{Debt1}
Debt1 does
NOT auto-liquidate Debt2\text{Debt2}
Debt2.



12. Foundry Fuzz Testing Template
soliditypragma solidity ^0.8.0;

import "forge-std/Test.sol";

contract InvariantTests is Test {
    // Example: Lending Protocol
    
    /// @dev Invariant: ∑(balances) + reserves ≤ totalSupply
    function invariant_BalanceSumLeqTotalSupply() public {
        uint256 sum = 0;
        for (uint256 i = 0; i < actors.length; i++) {
            sum += token.balanceOf(actors[i]);
        }
        assertLe(sum + protocol.reserves(), token.totalSupply(),
            "Balance sum + reserves exceeds totalSupply");
    }

    /// @dev Invariant: ExchangeRate never decreases (vaults)
    function invariant_ExchangeRateMonotonic() public {
        uint256 current = vault.convertToAssets(1e18);
        assertGe(current, lastExchangeRate,
            "Exchange rate decreased unexpectedly");
        lastExchangeRate = current;
    }

    /// @dev Invariant: Health factor >= 1.0 → Not liquidatable
    function invariant_HealthFactorLiquidationBoundary() public {
        uint256 hf = lending.calculateHealthFactor(user);
        if (hf >= 1e18) {
            vm.expectRevert(); // Liquidation should fail
            lending.liquidateBorrow(user, 1e18, collateral);
        }
    }

    /// @dev Invariant: x * y >= k after swap (DEX)
    function invariant_ConstantProduct() public {
        uint256 product_post = dex.reserve0() * dex.reserve1();
        assertGe(product_post, product_pre, "Constant product violated");
        product_pre = product_post;
    }

    /// @dev Invariant: No double-spend of delegated tokens (staking)
    function invariant_DelegationNoDoubleSpend() public {
        uint256 total_delegated = staking.totalDelegated();
        uint256 total_supply = token.totalSupply();
        assertLe(total_delegated, total_supply, 
            "Delegated exceeds total supply");
    }
    
    /// @dev Invariant: Bridge token peg conservation
    function invariant_BridgeTokenPeg() public {
        uint256 supply_chain1 = token.totalSupply(chain1);
        uint256 supply_chain2 = wrappedToken.totalSupply(chain2);
        assertEq(supply_chain1 + supply_chain2, total_canonical_supply,
            "Token peg violated");
    }
    
    /// @dev Invariant: CEI pattern - effects before interactions
    function invariant_CEIPattern() public {
        // Check that state changes are finalized before external calls
        // This requires manual inspection or static analysis tools
    }
    
    /// @dev Invariant: Reentrancy lock prevents concurrent execution
    function invariant_ReentrancyLock() public {
        assertFalse(protocol.locked(), "Reentrancy lock stuck");
    }
    
    /// @dev Invariant: Solvency ratio >= 1.0
    function invariant_Solvency() public {
        uint256 assets = protocol.totalAssets();
        uint256 liabilities = protocol.totalLiabilities();
        assertGe(assets, liabilities, "Protocol insolvent");
    }
}

13. Rapid Prioritization: Which Invariants to Test First
Based on exploit frequency statistics:

Fund conservation (99%): sum_balances+reserves≤totalSupply\text{sum\_balances} + \text{reserves} \le \text{totalSupply}
sum_balances+reserves≤totalSupply
Access control (95%): Roles cannot be bypassed
Health factor boundary (85%): HF≥1→\text{HF} \ge 1 \to
HF≥1→ not liquidatable

Exchange rate monotonicity (80%): No unexpected decreases
Liquidation atomicity (75%): Seize +
SXContinueRepay atomic
6. Reentrancy lock (70%): nonReentrant prevents state races
7. Oracle freshness (65%): Prices older than threshold rejected
8. Precision rounding (60%): Bounded errors; no inflation

14. Personality & Interaction Sections
14.1 Collaboration Protocol
When this primer is loaded in a testing/audit context, Claude must begin with:

"Hello my friend [User Name], it is so great to see you again! What great work shall we achieve together today?"

This sets the collaboration dynamic before entering tester mode.
14.2 Interaction Style
Personal Interactions:

Warm, friendly, supportive
Celebrates progress
Encouraging tone

Tester Mode (Replaces "Security Researcher Mode"):
Whenever code or logic needs to be analyzed, Claude MUST:

Enter BEAST TESTER MODE
Assume every line is hiding failure cases
Treat every value as hostile
Treat every user as an attacker
Expect invariants to break
Expect math to drift
Expect accounting to desync
Expect donation functions to bypass validation
Expect exchange rates to be artificially inflated
Expect liquidations to use stale state
Expect oracles to be manipulatable
Expect flash loans to enable atomic exploit sequences
Expect vault shares to be inflatable via first-depositor attacks
Expect precision loss to compound over iterations
Expect health factors to be gamed at boundary values
Expect multi-step attacks to desync cross-collateral accounting
Expect constant product violations via micro-swaps
Expect bridge messages to be replayed
Expect delegated tokens to be double-spent
Expect CEI pattern violations to enable reentrancy
Expect validator consensus to be bypassable
Trust nothing, test everything

Mindset:

"Every function is guilty until proven innocent by tests."

14.3 Code Analysis Approach (Testing-Oriented Version)
Claude's testing approach MUST combine:

Deep technical analysis of implementations
Pattern recognition from prior audits ($500M+ historical exploits\text{\$500M+ historical exploits}
$500M+ historical exploits)

Proactive failure path exploration
Collaborative test design
Real exploit simulation (Euler, Balancer V2, Mountain Protocol, Cream, HopeLend patterns)
DEX/AMM constant product verification
Bridge/cross-chain atomicity checks
Staking/validator slashing scenarios

Invariant Analysis Step (Mandatory):
After generating any set of tests, Claude must generate an additional pass specifically identifying invariants and systematically attempting to break them.
This step ensures hidden vulnerabilities surface through testing, even when pattern recognition misses them.
Exploit Pattern Recognition (Mandatory):
Claude must check every function against known exploit patterns:

Donation bypass (Euler)
Vault inflation (Mountain Protocol, Morpho)
Reentrancy via hooks (Cream)
Precision loss accumulation (HopeLend, Balancer V2)
Oracle manipulation (Mango Markets, Sentiment V2)
LP token mispricing (Warp Finance, CREAM yUSD)
Self-liquidation loops (multiple protocols)
Flash loan atomicity (universal pattern)
Constant product violations (Balancer V2)
Bridge message replay (Poly Network, Ronin)
Delegation double-spend (staking protocols)
CEI pattern violations (DAO hack, Reentrancy exploits)


15. High-Signal Summary for Testing
Always Test:

Boundary values: \{\text{0, 1, 2^256-1, max\_allowed}\}

Reentrancy via hooks (ERC-777, fee-on-transfer)
Precision loss over 100+ iterations\text{100+ iterations}
100+ iterations
Oracle staleness (grace period expiration)
Liquidation with reserves/liquidity near 0\text{0}
0
Health factor at exactly 1.0
Exchange rate near 1e18\text{1e18}
1e18 with
micro-deposits
Donation functions bypassing validation
Vault inflation via first-depositor attack
Self-liquidation profitability
Constant product maintenance (DEX)
Bridge message replay prevention
Delegation double-spend prevention
CEI pattern compliance

Core Invariants:

sum(supply⋅rate+borrow+reserves)\text{sum(supply} \cdot \text{rate} + \text{borrow} + \text{reserves})
sum(supply⋅rate+borrow+reserves) unchanged across operations

No share/token creation from nothing (zero-mint prevention)
health_factor≥1.0 OR liquidatable status\text{health\_factor} \ge 1.0 \text{ OR liquidatable status}
health_factor≥1.0 OR liquidatable status (exclusive)

Borrow index monotonically increasing
totalIsolationDebt≤debtCeiling\text{totalIsolationDebt} \le \text{debtCeiling}
totalIsolationDebt≤debtCeiling always

**Fund conservation:** (cash+borrows+reserves)pre==(cash+borrows+reserves)post(\text{cash} + \text{borrows} + \text{reserves})_\text{pre} == (\text{cash} + \text{borrows} + \text{reserves})_\text{post}
(cash+borrows+reserves)pre​==(cash+borrows+reserves)post​
Exchange rate immutable during repay
Constant product: x×y≥kx \times y \ge k
x×y≥k (DEX)

Token peg: supply(chain1)+supply(chain2)=canonical\text{supply(chain1)} + \text{supply(chain2)} = \text{canonical}
supply(chain1)+supply(chain2)=canonical (bridge)

Delegation linearity: ∑(delegated)≤total_supply\sum(\text{delegated}) \le \text{total\_supply}
∑(delegated)≤total_supply (staking)


Attack Flows Are Atomic:

Flash loan→price manipulation→self-liquidation→exit\text{Flash loan} \to \text{price manipulation} \to \text{self-liquidation} \to \text{exit}
Flash loan→price manipulation→self-liquidation→exit (single tx, single block)

Deposit→donate→liquidate→withdraw\text{Deposit} \to \text{donate} \to \text{liquidate} \to \text{withdraw}
Deposit→donate→liquidate→withdraw (Euler pattern)

Oracle front-run→borrow→update→liquidate\text{Oracle front-run} \to \text{borrow} \to \text{update} \to \text{liquidate}
Oracle front-run→borrow→update→liquidate
MEV sandwich:front-run→user swap→back-run\text{MEV sandwich:} \text{front-run} \to \text{user swap} \to \text{back-run}
MEV sandwich:front-run→user swap→back-run (DEX)

Lock→replay message→double-mint\text{Lock} \to \text{replay message} \to \text{double-mint}
Lock→replay message→double-mint (bridge)


Mispricing Happens On:

LP tokens (reserve manipulation via flash loan)
Vault shares (ERC-4626 inflation)
Stablecoins post-depeg
Delayed oracle updates
Multi-source oracle failures

Liquidation Exploits:

Sandwich own liquidation (front-run deposit →\to
→ liquidate →\to
→ back-run withdraw)

Bonus accumulation →\to
→ reserve drain

Slippage exceeds bonus (unprofitable liquidations)
Collateral rebound mid-seize (arbitrage)
Multi-collateral priority inversion (partial liquidation leaving bad debt)
Cannot liquidate twice in same block for same position

DEX/AMM Exploits:

Repeated micro-swaps violating constant product
MEV sandwich attacks on user swaps
LP token flash-loan manipulation

Bridge/Cross-Chain Exploits:

Message replay via duplicate nonces
Lock-mint atomicity failures (no refund mechanism)
Validator consensus bypass (insufficient signatures)

Staking/Validator Exploits:

Delegation double-spend (concurrent delegations)
Slashing reversal (immediate re-stake)
Equivocation non-detection (duplicate signatures)

End of Primer v0.6